<link rel="import" href="../tangere/tangere.html">
<link rel="import" href="../at-theme/at-theme.html">
<link rel="import" href="../at-i18n/at-i18n-behavior.html">
<link rel="import" href="../at-form-behaviors/at-form-behaviors.html">
<link rel="import" href="../at-core-activity/at-core-activity.html" />
<link rel="import" href="../iron-label/iron-label.html">
<link rel="import" href="../at-core-view/at-core-view.html">
<link rel="import" href="../at-core-dropdown/at-core-dropdown.html" />
<link rel="import" href="at-form-lookup-input-validation-behavior.html">
<link rel="import" href="at-form-lookup-styles.html">
<link rel="import" href="../at-core-spinner/at-core-spinner.html" />
<link rel="import" href="../at-carbon-message/at-carbon-message.html" />
<link rel="import" href="items-view.html" />
<link rel="import" href="options-view.html" />

<dom-module id="at-form-lookup">
  <template>
    <style include="at-form-common"></style>
    <style include="at-form-lookup-styles">
      :host {
        @apply(--at-form-host);
        box-sizing: border-box;
      }
    </style>
    
    <at-core-activity id="coreAjax" url="[[url]]" params="[[params]]" on-response="_handleCoreAjaxOnResponse" on-error="_handleCoreAjaxOnError"></at-core-activity>
    <at-core-spinner id="coreSpinner"></at-core-spinner>
    <at-carbon-message id="carbonMessage" type="info"></at-carbon-message>
    
    <div id="atContainer" class="at-container" hidden>
        <!--
        Introduced label container as a workaround for a bug with opacity calculation in polymer-js
        Right now, if opacity is changed via js by setting a disabled class on iron-label, iron-label is not styled correctly
        And changing its text also doesn't work correctly when disabled class is set
        In the workaround, disabled class is set on the container.
      -->
      <div id="labelContainer">
        <iron-label id="label" on-tap="focus">{{label}}</iron-label>
      </div>
      
      <div id="contentContainer" class="at-content-container">
        <items-view id="itemsView" multiple$="[[_computeMultiple(maxItems)]]"></items-view>
      </div>

      <at-core-dropdown id="coreDropdown" no-mask>
        <options-view id="optionsView"></options-view>
      </at-core-dropdown>

      <div id="hint" class="hint"></div>
    </div>
  </template>
</dom-module>
<script>
  'use strict';

  Polymer({
    is: 'at-form-lookup',
    behaviors: [ Tangere.behaviors.i18n, Tangere.behaviors.formUIGeneric, Tangere.behaviors.AtFormLookupInputValidation ],

    properties: {
      /**
       * Element's label for element display purposes
       * @property label
       * @type String
       * @default ""
       */
      label: {
        type: String,
        value: '',
        title: 'Label'
      },

      /**
       * Hides label when true
       * @property hideLabel
       * @type Boolean
       * @default false
       */
      hideLabel: {
        type: Boolean,
        value: false,
        observer: '_hideLabelChanged',
        title: 'Do not show the label'
      },

      /**
       * Element's disabled state
       * @property disabled
       * @type Boolean
       * @default false
       */
      disabled: {
        type: Boolean,
        value: false,
        observer: '_disabledChanged',
        title: 'Field value can not be changed'
      },

      /**
       * Hides the element. When hidden nothing is displayed for the element
       * @property hide
       * @type Boolean
       * @default false
       */
      hide: {
        type: Boolean,
        value: false,
        observer: '_hideChanged',
        title: 'Field is invisible'
      },

      /**
       * Element's required state for element validation purposes
       * @property required
       * @type Boolean
       * @default false
       */
      required: {
        type: Boolean,
        value: false,
        title: 'Input required'
      },

      /**
       * The list of items that should initially be present for selection
       * value should be provided as a comma separated values (CSV) string
       * @property available
       * @type String
       * @default ""
       */
      available: {
        type: String,
        value: ''
      },
      // ------------------------------------------------------------
      // "Why is xvaluelist here?" - you ask.
      // "We already have available just above" - you say.
      // xvaluelist is here to improve compatibility with copyProperties function in at-core-form/script/schema-helpers.js
      // this function goes through element properties and copies property values from property definition in json schema to element properties
      // now available doens't exist in property definition in json schema so undefined will be copied
      // xvaluelist exists in json schema and when property name is valuelist, xvaluelist should be copied
      // so we introduce xvaluelist property in at-form-radio to remove if statement that would detect this situation
      // ------------------------------------------------------------
      /**
       * The list of items that should initially be present for selection
       * value should be provided as an array of title, value objects
       * @property xvaluelist
       * @type Array
       * @default []
       */
      xvaluelist: {
        type: Array,
        value: function() {
          return [];
        },
        schema: {
          items: {
            type: "object",
            properties: {
              title: {
                "type": "string"
              },
              value: {
                type: "string"
              }
            }
          }
        },
        layout: 'horizontal',
        xgridcols: '12',
        title: 'Value List'
      },
      // ------------------------------------------------------------
      // "Why is enum here?" - you ask.
      // "We already have available and xvaluelist just above" - you say.
      // read explanation for xvaluelist, enum is here for the same reason
      // ------------------------------------------------------------
      /**
       * The list of items that should initially be present for selection
       * value should be provided as an array of strings
       * @property enum
       * @type Array
       * @default []
       */
      enum: {
        type: Array,
        value: function() {
          return [];
        },
        schema: {
          items: {
            type: "string",
            properties: {
              value: {
                type: "string"
              }
            }
          }
        },
        layout: 'horizontal',
        title: 'Values'
      },

      /**
       * Elements value. Value is a CSV string
       * @property value
       * @type String
       * @default empty string
       */
      value: {
        type: String,
        value: '',
        title: 'Value'
      },

      /**
       * initialSearchTerm - when set/changed the current values are cleared and it behaves like having typed that value
       * @property initialSearchTerm
       * @type String
       * @default ""
       */
      initialSearchTerm: {
        type: String,
        value: "",
        title: 'Initial Search Term'
      },

      /**
       * Elements value as an array of selected objects
       * @property selectedItems
       * @type Array
       * @default []
       */
      selectedItems: {
        type: Array,
        value: function () {
          return [];
        },
        xtype: 'json',
        readOnly: true
      },

      /**
       * When true no authentication is sent to the server
       * @property noCredentials
       * @type Boolean
       * @default false
       */
      noCredentials: {
        type: Boolean,
        value: false
      },

      /**
       * When true initial request to popluate the available items is not set
       * @property noPreload
       * @type Boolean
       * @default false
       */
      noPreload: {
        type: Boolean,
        value: false
      },

      /**
       * Remote url from where to get items from
       * @property url
       * @type String
       * @default ""
       */
      url: {
        type: String,
        value: '',
        observer: '_urlChanged',
        title: 'Url'
      },

      /**
       * Remote url from where to get items from
       * @property xurl
       * @type String
       * @default ""
       */
      xurl: {
        type: String,
        value: '',
        observer: '_urlChanged'
      },

      /**
       * Additional params to send with each request
       * @property params
       * @type String
       * @default ""
       */
      params: {
        type: String,
        value: '',
        observer: '_paramsChanged'
      },

      /**
       * When true new entries are created when no matching record is found
       * @property allowNewItems
       * @type Boolean
       * @default false
       */
      allowNewItems: {
        type: Boolean,
        value: false,
        observer: '_allowNewItemsChanged',
        title: 'Allow new entries'
      },

      /**
       * Maximum count of items that can be selected
       * @property maxItems
       * @type Number
       * @default 1
       */
      maxItems: {
        type: Number,
        value: 1,
        observer: '_maxItemsChanged',
        title: 'Maximum number of selectable items'
      },

      /**
       * Liquid template to render options in the dropdown with
       * 
       * @property itemView
       * @type String
       * @default ''
       */
      itemView: {
        type: String,
        title: "Item view",
        value: '',
        observer: "_itemViewChanged",
        xtype: "code",
        mode: "carbon"
      },

      /**
       * view model objects that holds internal state of the element
       * 
       * @property _viewModel
       * @type Object
       * @default {}
       */
      _viewModel: {
        type: Object,
        value: function() {
          return {};
        }
      }

    },

    $meta: [{
      title: "Enum",
      type: "string",
      xtype: "enum"
    }, {
      title: "Lookup",
      type: "string",
      xtype: "lookup"
    }],

    observers: [
      '_internalValidStateUpdate(required)',
      '_initialize(available, enum, xvaluelist, value, url, xurl, noCredentials, noPreload, params, initialSearchTerm, maxItems)'
    ],

    _hideLabelChanged: function(newValue, oldValue) {
      this.toggleClass("hidden", newValue, this.$.label);
    },

    // computes multiple attribute for items-view
    _computeMultiple: function(maxItems) {
      var value = parseInt(maxItems);
      if (isNaN(value)) {
        value = 0;
      }
      return value !== 1;
    },

    ready: function() {

      // *ij* 17.06.2016 (dd.mm.yyyy)
      // there is a requirement for 'required' at-form-*elements that they initially be displayed
      // as valid event when they are initially invalid;
      // on first focus/blur sequence they should be displayed as invalid
      // code bellow provides for display as invalid on first focus/blur sequence
      // this was discovered with unit testing
      var self = this;
      var focusable = this._getFocusableElement();
      if (focusable) {
        focusable.addEventListener('blur', function(event) {
          self.validate();
        });
      }

      // call into at-form-behaviors.formUIGeneric._attachFocusBlurEvents
      this._attachFocusBlurEvents();
    },

    attached: function() {
      this._boundWidnowScrollEventHandler = this._handleWindowScrollEvent.bind(this);
      // we want to close the dropdown on scroll or resize
      window.addEventListener('scroll', this._boundWidnowScrollEventHandler);
      window.addEventListener('resize', this._boundWidnowScrollEventHandler);
    },

    detached: function() {
      // cleanup
      window.removeEventListener('scroll', this._boundWidnowScrollEventHandler);
      window.removeEventListener('resize', this._boundWidnowScrollEventHandler);
    },

    _handleWindowScrollEvent: function() {
      // close the dropdown
      this.$.coreDropdown.hide();
    },

    _disabledChanged: function(newValue, oldValue) {
      this.toggleClass('disabled', newValue, this.$.labelContainer);

      // TODO(ij): disable items view
    },

    _hideChanged: function(newValue, oldValue) {
      this.toggleClass('hidden', newValue, this.$.atContainer);
    },

    _internalValidStateUpdate: function (required) {
      if (this._isReady) {
        this.validate();
      }
    },

    validate: function (showError) {
      if (showError === undefined) { showError = this.autoValidate; }

      var validationResult = this._validateBaseData();
      this._handleValidationResult(validationResult);
      if (!validationResult.isValid) {
        return validationResult.isValid;
      }

      validationResult = this._validateData(this, this.value, this.T.bind(this));
      if(showError) this._handleValidationResult(validationResult);
      if (!validationResult.isValid) {
        return validationResult.isValid;
      }
      /*
        if user typed text into text input but didn't select an item we
        1) do not want text to be deleted
        2) we want to display a validation error message if user typed but didn't select an item
        * this._selectizeInstance.$control_input.value contains value that user typed
        * this.value is empty if user didn't select an item
       */
      var userTypedText = this._getInput().value;
      if (
        userTypedText.length && // if user typed text
        !this.value.length // but didn't select a value
      ) {
        // report the error
        validationResult.isValid = false;
        validationResult.errorMessage = this.T("Please select a record");
      } else {
        validationResult.isValid = true;
      }
      if (showError) this._handleValidationResult(validationResult);

      return validationResult.isValid;
    },

    _updateUIValidState: function(isValid) {
      var label = this.$.label;
      this.toggleClass('error', !isValid, label);
      var contentContainer = this.$.contentContainer;
      this.toggleClass('error', !isValid, contentContainer);
    },

    _initialize: function(available, enumarr, xvaluelist, value, url, xurl, noCredentials, noPreload, params, initialSearchTerm, maxItems) {

      var self = this;
      // debounce the initialization to avoid mutliple function calls in two use cases
      // 1. during polymer element lifecycle function calls
      // 2. in playground
      // 3. in form designer
      this.debounce('debounce-initialization', function() {
        self._initializeDebounced(available, enumarr, xvaluelist, value, url, xurl, noCredentials, noPreload, params, initialSearchTerm, maxItems);
      }, 250);
    },

    _initializeDebounced: function(available, enumarr, xvaluelist, value, url, xurl, noCredentials, noPreload, params, initialSearchTerm, maxItems) {
      console.log(`_initializeDebounced`);

      // console.log(`available ${available}`);
      // console.log(`enum ${JSON.stringify(enumarr)}`);
      // console.log(`xvaluelist ${JSON.stringify(xvaluelist)}`);
      // console.log(`value ${value}`);
      // console.log(`initialSearchTerm ${initialSearchTerm}`);
      // console.log(`url ${url}`);
      // console.log(`xurl ${xurl}`);
      // console.log(`noCredentials ${noCredentials}`);
      // console.log(`noPreload ${noPreload}`);
      // console.log(`params ${JSON.stringify(params)}`);

      // detect if we work with local or remote data source
      if (!url && !xurl) {
        // we are working with local data source
        this._initializeLocalDataSource(available, enumarr, xvaluelist, value, initialSearchTerm, maxItems);

      } else {
        // we are working with remote data source
        this._initializeRemoteDataSource(url, xurl, noCredentials, noPreload, params, initialSearchTerm, maxItems);
      }
    },

    _initializeLocalDataSource: function(available, enumarr, xvaluelist, value, initialSearchTerm, maxItems) {

      // 1. compute available options
      var availableOptions = xvaluelist || enumarr || available;
      var vmOptions = [];

      function isArray(obj) { return Object.prototype.toString.apply(obj) === "[object Array]"; }
      function isString(obj) { return Object.prototype.toString.apply(obj) === "[object String]"; }
      function isObject(obj) { return Object.prototype.toString.apply(obj) === "[object Object]"; }
      function isCommaSeparated(obj) { return isString(obj) && obj.indexOf(',') > -1; }

      if (isArray(availableOptions)) {
        availableOptions.forEach(function(option) {
          if (isString(option)) {
            option = option.trim();
            vmOptions.push({
              title: option,
              value: option
            });
          } else if (isObject(option)) {
            if (!option.title) {
              option.title = option.value;
            }
            vmOptions.push(option);
          }
        });

      } else if (isCommaSeparated(availableOptions)) {
        availableOptions = availableOptions.split(',');
        availableOptions.forEach(function(option) { 
          option = option.trim();
          vmOptions.push({
            title: option,
            value: option
          });
        });
      }

      // 2. put available options into options-view
      this.$.optionsView.items = vmOptions;

      // 3. compute initially selected items based on value
      if (isString(value) && value.length) {
        // value is a csv string
        var valueParts = value.split(',');
        var selectedOptions = [];
        
        for (var i = 0; i < valueParts.length; i++) {
          var vmOption = null;
          var valuePart = valueParts[i];
          valuePart = valuePart.trim();
          var found = false;
          for (var j = 0; j < vmOptions.length && !found; j++) {
            vmOption = vmOptions[j];
            found = vmOption.value === valuePart;
          }

          if (found) {
            selectedOptions.push(vmOption);
          }
        }

        if (maxItems === 1) {
          selectedOptions.splice(1);
          
        } else if (maxItems > 1) {
          selectedOptions.splice(maxItems, selectedOptions.length - maxItems);

          var remainingOptions = [];
          vmOptions.forEach(function(option) {
            var value = option.value;
            var found = false;
            for (var i = 0; i < selectedOptions.length && !found; i++) {
              var selected = selectedOptions[i];
              found = selected.value === value;
            }
            if (!found) {
              remainingOptions.push(option);
            }
          });
          this.$.optionsView.items = remainingOptions;
        }

        this.$.itemsView.items = selectedOptions;

      } else {
        if (!isString(value)) {
          console.log('type of value is ' + (typeof value));
        }
      }

      // 4. put initalSearchTerm into filterTextInput
      this._getInput().value = initialSearchTerm;

      // 5. hide the spinner
      this.$.coreSpinner.display = 'none';

      // 6. show the element
      this.$.atContainer.removeAttribute('hidden');

      // 7. attach relevant events
      this._setupEventListeners();
    },

    _initializeRemoteDataSource: function(url, xurl, noCredentials, noPreload, params, initialSearchTerm, maxItems) {
      // 1. compute available options

      // 2. put available options into options-view

      // 3. compute initially selected items based on value

      // 4. put initalSearchTerm into filterTextInput
    },

    _setupEventListeners: function() {
      var filterTextInput = this._getInput();

      if (!this._boundFilterTextInputFocusHandler) {
        this._boundFilterTextInputFocusHandler = this._handleFilterTextInputFocusEvent.bind(this);
      }
      filterTextInput.addEventListener('focus', this._boundFilterTextInputFocusHandler);

      if (!this._boundFilterTextInputBlurHandler) {
        this._boundFilterTextInputBlurHandler = this._handleFilterTextInputBlurEvent.bind(this);
      }
      filterTextInput.addEventListener('blur', this._boundFilterTextInputBlurHandler);

      if (!this._boundFilterTextInputKeydownHandler) {
        this._boundFilterTextInputKeydownHandler = this._handleFilterTextInputKeydownEvent.bind(this);
      }
      filterTextInput.addEventListener('keydown', this._boundFilterTextInputKeydownHandler);

      if (!this._boundItemsViewItemsDeletedHandler) {
        this._boundItemsViewItemsDeletedHandler = this._handleItemsViewItemsDeletedEvent.bind(this);
      }
      this.$.itemsView.addEventListener('items-deleted', this._boundItemsViewItemsDeletedHandler);

      if (!this._boundOptionsViewOptionSelectedHadler) {
        this._boundOptionsViewOptionSelectedHadler = this._handleOptionsViewOptionSelectedEvent.bind(this);
      }
      this.$.optionsView.addEventListener('option-selected', this._boundOptionsViewOptionSelectedHadler);
    },

    _detachEventListeners: function() {
      var itemsView = this.$.itemsView;
      var filterText = itemsView.$.filterTextInput;
      filterTextInput.removeEventListener('focus', this._boundFilterTextInputFocusHandler);
      filterTextInput.removeEventListener('blur', this._boundFilterTextInputBlurHandler);

      itemsView.removeEventListener('items-deleted', this._boundItemsViewItemsDeletedHandler);

      this.$.optionsView.removeEventListener('option-selected', this._boundOptionsViewOptionSelectedHadler);
    },

    _handleFilterTextInputFocusEvent: function(event) {
      var isFull = this._isFull();
      var isMulti = this._isMultiSelect();
      
      if (isFull && isMulti) return;

      if (!this.$.optionsView.items.length) return;
      this.$.coreDropdown.show(null, this.$.itemsView);
    },

    _handleFilterTextInputBlurEvent: function(event) {
      if (!event.relatedTarget) {
        // if focus didn't transfer to any other element hide the dropdown
        this.$.coreDropdown.hide();
        return;
      }

      // if element receiving focus is at-core-dropdown-impl return
      if (event.relatedTarget.nodeName === "AT-CORE-DROPDOWN-IMPL") return;

      // if element receiving focus is an item in <items-view> return
      if (event.relatedTarget.classList.contains('item')) return;

      // if element receiving focus is outside at-form-lookup hide the dropdown
      this.$.coreDropdown.hide();
    },

    _handleFilterTextInputKeydownEvent: function(event) {
      var keyCode = event.keyCode;

      var VK_BACKSPACE = 8;
      var VK_TAB = 9;
      var VK_ENTER = 13;
      var VK_UP = 38;
      var VK_DOWN = 40;
      var VK_ESCAPE = 27;

      switch (keyCode) {
        case VK_ESCAPE:
          this.$.coreDropdown.hide();
          break;

        case VK_ENTER:
        case VK_TAB:
          // select highlighted element
          var selectedIndex = this._findSelectedIndex(this.$.optionsView.items);
          if (selectedIndex < 0) return;
          this._selectOptionAtIndex(selectedIndex);

          // for keyboard input select item near to currently selected to make selecting next more user friendly
          if (selectedIndex === this.$.optionsView.items.length) selectedIndex-=1;
          this.$.optionsView.set('items.' + selectedIndex + '.selected', true);
          break;

        case VK_UP: 
          // highlight previous element 
          this._highlightPrevious(this.$.optionsView.items);
          break;

        case VK_DOWN: 
          // highlight next element 
          this._highlightNext(this.$.optionsView.items);
          break;

        case VK_BACKSPACE: 
          if (this._isFull()) return;
          this.$.coreDropdown.show(null, this.$.itemsView);
          break;
      }
    },

    _findSelectedIndex: function(options) {
      for (var i = 0; i < options.length; i++) {
        var option = options[i];
        if (option.selected) return i;
      }
      return -1;
    },

    _selectOptionAtIndex: function(selectedIndex) {
      var isFull = this._isFull();
      var isMulti = this._isMultiSelect();
      
      if (isFull && isMulti) return;

      var option = this.$.optionsView.items[selectedIndex];
      if (isFull && !isMulti) {
        // maxItems == 1 and itemsView already displays selected item
        // replace that item with newly selected one
        this.$.itemsView.splice('items', 0, 1, option);

      } else {
        // add selected option to the items view
        this.$.itemsView.push('items', option);

        if (isMulti) {
          this.$.optionsView.splice('items', selectedIndex, 1);
          if (!this.$.optionsView.items.length) {
            this.$.coreDropdown.hide();
          }
        }
      }

      // if maxItems have been selected close the dropdown
      if (this._isFull()) {
        this.$.coreDropdown.hide();
      }
    },

    _highlightPrevious: function(options) {
      var selectedIndex = this._findSelectedIndex(options);
      if (selectedIndex < 1) return;
      this.$.optionsView.set('items.' + selectedIndex + '.selected', false);
      selectedIndex -= 1;
      if (selectedIndex < 0) return;
      this.$.optionsView.set('items.' + selectedIndex + '.selected', true);
    },

    _highlightNext: function(options) {
      var selectedIndex = this._findSelectedIndex(options);
      if (selectedIndex > -1 && selectedIndex < options.length-1) {
        this.$.optionsView.set('items.' + selectedIndex + '.selected', false);
      }
      selectedIndex +=1;
      if (selectedIndex > options.length) return;
      this.$.optionsView.set('items.' + selectedIndex + '.selected', true);
    },

    _handleItemsViewItemsDeletedEvent: function(event) {
      if (!this._isMultiSelect()) return;
      var itemsDeleted = event.detail.value;
      itemsDeleted.forEach(function(item) {
        item.selected = false;
        this.$.optionsView.push('items', item);
      }.bind(this));

      this.$.optionsView.items.sort(function(i1, i2) { 
        return i1.value > i2.value;
      });
      var sortedItems = this.$.optionsView.items;
      this.$.optionsView.set('items', []);
      this.$.optionsView.set('items', sortedItems);

      if (itemsDeleted.length && !this.$.coreDropdown.open) {
        // focusing the input will open the dropdown 
        this._getInput().focus();
      }
      // console.log('items-view items-deleted ' + JSON.stringify(event.detail.value));
    },

    _handleOptionsViewOptionSelectedEvent: function(event) {
      var selectedIndex = this._findSelectedIndex(this.$.optionsView.items);
      if (selectedIndex > -1) {
        this.$.optionsView.set('items.' + selectedIndex + '.selected', false);
      }
      var index = event.detail.index;
      this.$.optionsView.set('items.' + index + '.selected', true);
      this._selectOptionAtIndex(index);
      
      this._getInput().focus();
    },

    // this function is here to improve compatibility with form designer
    xvaluelistChanged: function(newValue, oldValue) {
      this._availableChanged(newValue, oldValue);
    },

    // 
    // 
    // 
    // HELPER FUNCTIONS
    // 
    // 
    // 

    // returns true if maxItems have already been selected from available options
    _isFull: function() {     
      return this.maxItems === 0 ? false : this.$.itemsView.items.length === this.maxItems;
    },

    // returns true if user can select more than one item
    _isMultiSelect: function() {
      // if maxItems = 0 there is no limit for item selection, user can select as many items as there are available options
      // if maxItems > 1 user can select maxItems items from available options
      // TODO(ij): when maxItems > availableOptions.lenth code should not break
      return this.maxItems !== 1;
    },

    _getInput: function() {
      return this.$.itemsView.$.filterTextInput;
    },

    _valueChanged: function(newValue, oldValue) {
      if (this._isReady) {
        if (!this._isUpdating && !this._selectizeUpdate) {
          this._isUpdating = true;

          // do the update
          var sInstance = this._selectizeInstance;

          var newValues = this.value;
          if (!isArray(newValues)) {
            // newValue can be string, array or number; if its number we convert it to string
            if (!isString(newValues)) {
              newValues = String(newValues);
            }
            if (newValues.length <= 0) {
              newValues = new Array();
            } else {
              newValues = newValues.split(',');
            }
          }

          var selectedItems = sInstance.items;

          var arrIntersection = arrayIntersect(newValues, selectedItems);
          var itemsToAdd = arraySubtract(newValues, arrIntersection);
          var itemsToRemove = arraySubtract(selectedItems, arrIntersection);

          for (var i = 0; i < itemsToRemove.length; i++) {
            sInstance.removeItem(itemsToRemove[i]);
          }

          var coreActivityQueue = [];
          this._issuedRequestsQueue = [];

          for (var i = 0; i < itemsToAdd.length; i++) {
            var currentItem = itemsToAdd[i];

            if (sInstance.options.hasOwnProperty(currentItem)) {
              sInstance.addItem(currentItem);
            } else {
              if (this._internalUrl && this._internalUrl !== "" && currentItem !== "") {
                // *ij* this here is request by *ma*
                // at-form-lookup should work in orchard without any additional configuration
                // code bellow makes that possible
                // component is first disabled so user can't input
                this._selectizeInstance.disable();
                // an disabled overlay is "displayed"
                Polymer.dom(this.$.disabledOverlay).setAttribute('disabled', true);
                // a correct url is constructed
                var urlParts = this._internalUrl.split('?');
                var baseUrl = urlParts[0];
                var queryPart = urlParts.length > 1 ? '?' + urlParts[1] : '';
                var coreActivity = document.createElement('at-core-activity');
                coreActivity.handleAs = 'json';
                var finalUrl = baseUrl + '/' + currentItem + queryPart;
                coreActivity.url = finalUrl;
                // noCredentials parameter is set on the ajax component
                coreActivity.noCredentials = this.noCredentials;
                // add listener for response event
                coreActivity.addEventListener('response', this._loadDefaultOnResponse.bind(this));
                coreActivity.addEventListener('error', this._loadDefaultOnError.bind(this));

                // put current request in a queue
                coreActivityQueue.push(coreActivity);
                // create an entry in issued requests queue
                this._issuedRequestsQueue.push({
                  requestItemId: currentItem,
                  isCompleted: false
                });
              }
            }
          }

          // generate requests for each core activity
          coreActivityQueue.forEach(function (coreActivity, index) {
            // request is made
            coreActivity.generateRequest();
          });

          this._isUpdating = false;
          this._selectizeUpdate = false;
        }

        if (this.autoValidate) { this.validate(); }

        this._fireValueChangedEvent(newValue);
      }
    },

    _initialSearchTermChanged: function (newValue, oldValue) {
      if (!this._isReady || !this._selectizeInstance) { return; }
      var optionsLength = Object.keys(this._selectizeInstance.options);
      if (!optionsLength) { return; }
      if (this._selectizeInstance.isFull()) { return; }

      this._selectizeInstance.$control_input.value = newValue;
      var updateEvent = new CustomEvent('keyup', {});
      this._selectizeInstance.$control_input.dispatchEvent(updateEvent);

      // we open the dropdown manually because 'keyup' event doesn't do it reliably
      this._selectizeInstance.open();
    },

    set selectedItems(newValue) {},

    _urlChanged: function(newValue, oldValue) {
      if (this._isReady) {
        this.noPreload = true;
        if (this.xurl && this.xurl !== ""){
          this._internalUrl = this.xurl;
        } else if (this.url && this.url !== "") {
          this._internalUrl = this.url;
        }

        if (this._internalUrl && this._internalUrl !== '') {
          this.noPreload = false;
        }

        this._request_paramsChanged();
        // AT-32 when value is set before url, that value needs to be displayed
        this._valueChanged(this.value, this.value);
        this.xurl = this.url; // update legacy xurl parameter
      }
    },

    _paramsChanged: function() {
      if (this._isReady) {
        this.noPreload = true;
        if (this.params !== '') {
          this.noPreload = false;
        }
        this._request_paramsChanged();
      }
    },

    _request_paramsChanged: function() {
      if (this._selectizeInstance.clear && this._selectizeInstance.clearOptions) {
        this._selectizeInstance.clear();
        this._selectizeInstance.clearOptions();
        this._selectizeInstance.onSearchChange('');
      }
    },

    _allowNewItemsChanged: function(newValue, oldValue) {
      if (this._isReady && this._selectizeInstance) {
        var valueToSet = Boolean(newValue);
        this._selectizeInstance.settings.create = valueToSet;
      }
    },

    _maxItemsChanged: function(newValue, oldValue) {
      if (this._isReady && this._selectizeInstance) {
        try {
          // ok what is happening here?
          // 1. we calculate what is value to set is by using Number constructor function
          var valueToSet = parseInt(newValue);
          if (isNaN(valueToSet)) {
            valueToSet = 0;
          }
          // 2. we need to update selectize settings
          var settings = this._selectizeInstance.settings;
          // 3. we need to update maxItems
          settings.maxItems = valueToSet < 1 ? null : valueToSet;
          // we need to set mode; I found out that I need to do this by inspecting and debuggin selectize code
          var mode = valueToSet === 1 ? 'single' : 'multi';
          // we also need to remember current value for mode
          var prevMode = settings.mode;
          // we set the new mode value
          settings.mode = mode;
          // we also need to set this setting when mode is multi
          settings.hideSelected = mode === 'multi';
          // we need to set classes on $wrapper and $dropdown; I found out that I need to do this by inspecting and debuggin selectize code
          var wrapper = this._selectizeInstance.$wrapper;
          Polymer.dom(wrapper).classList.remove(prevMode);
          Polymer.dom(wrapper).classList.add(mode);
          var dropdown = this._selectizeInstance.$dropdown;
          Polymer.dom(dropdown).classList.remove(prevMode);
          Polymer.dom(dropdown).classList.add(mode);
          // now we update the view
          var instance = this._selectizeInstance;
          // we need to clear the cache; this is clearing the rencer cache; we need to do this because after mode change the way items are rendered changes
          // so cache needs to be updated
          instance.clearCache();
          // we run setup plugins; remove_button plugin behaves differently based on mode; its disabled in single and enabled in multi
          // since mode is updated plugins need to update themselves
          instance.setupPlugins();
          // finally we update selected items
          var oldItems = instance.items;
          instance.clear();
          var itemsLength = oldItems.length;
          var i;
          // if maxItems < length of currently selected items we need to trim
          if (valueToSet < itemsLength) {
            for (i = 0; i < valueToSet; i++) {
              var oldItem = oldItems[i];
              instance.addItem(oldItem);
            }
          } else {
          // else maxItems >= length so we do not trim
            for (i = 0; i < itemsLength; i++) {
              var oldItem = oldItems[i];
              instance.addItem(oldItem);
            }
          }
        } catch (e) {
          console.log(e);
        }
      }
    },

    _itemViewChanged: function(newValue, oldValue) {
      if (this._isReady && this._selectizeInstance) {

        if (!this._originalOptionRender) {
          this._originalOptionRender = this._selectizeInstance.settings.render.option;
        }

        var render = {};

        if (newValue && newValue !== "") {
          render.option = function (data, escape) {
              return '<at-core-view class="item" view="'+ newValue +'" value=\''+ JSON.stringify(data) +'\'></at-core-view>';
            };
          this._selectizeInstance.renderCache = {};
        } else {
          if (this._originalOptionRender) {
            render.option = this._originalOptionRender;
          }
        }

        var extend = function(a, b) {
          var i, n, k, object;
          for (i = 1, n = arguments.length; i < n; i += 1) {
            object = arguments[i];
            if (!object) {
              continue;
            }
            for (k in object) {
              if (object.hasOwnProperty(k)) {
                a[k] = object[k];
              }
            }
          }
          return a;
        };

        this._selectizeInstance.settings.render = extend({}, this._selectizeInstance.settings.render, render);
        this._selectizeInstance.refreshOptions(false);
      }
    },

    _handleCoreAjaxOnError: function(event) {
      this.$.disabledOverlay.removeAttribute('disabled');
      this._selectizeInstance.enable();
    },

    _handleCoreAjaxOnResponse: function(event) {
      // extract the data from the event
      var eventObject = {
        response: event.detail,
        returnData: []
      };
      this.fire('at-form-lookup-afterAjax', eventObject);

      if (!this._selectizeLoadCallback) {
        this.$.disabledOverlay.removeAttribute('disabled');
        if (!this.disabled) {
          this._selectizeInstance.enable();          
        }
        return;
      }
      
      if (eventObject.returnData.length > 0) {
        this._selectizeLoadCallback(eventObject.returnData);
      } else {
        var data = [];
        // we check if property exists with hasOwnProperty check
        // if property exists, we check if value not not false (so not false, 0, null, undefined or "")
        if (event.hasOwnProperty('detail') && event.detail && 
            event.detail.hasOwnProperty('Data') && event.detail.Data && 
            event.detail.Data.hasOwnProperty('items') && event.detail.Data.items
          ) {
          data = event.detail.Data.items;
        }
        var dataArray = [];
        for (var i = 0; i < data.length; i++) {
          var entry = data[i];
          entry.value = entry.id;
          //dataArray.push({ value: entry.id, title: entry.title });
          dataArray.push(entry);
        }
        this._selectizeLoadCallback(dataArray);
      }

      if (!this._issuedRequestsQueue.length) {
        this.$.disabledOverlay.removeAttribute('disabled');
      }
      if (!this.disabled) {
        this._selectizeInstance.enable();
      }
    },

    _selectizeOnLoad: function(query, callback) {
      // this here is selectize object
      // polymer element upon which selectize is constructed is passed into selectize settings and can be accessed here
      if (this._internalUrl && this._internalUrl !== '') {

        this.$.coreAjax.params = {};

        var urlParts = this._internalUrl.split('?');
        var baseUrl = urlParts[0];
        var queryPart = urlParts.length > 1 ? urlParts[1] : '';

        var queryPieces = queryPart.split('&');
        var index;
        for (index = 0; index < queryPieces.length; index++) {
          var queryPiece = queryPieces[index];
          var pieceParts = queryPiece.split('=');
          if (pieceParts.length && pieceParts.length === 2) {
            this.$.coreAjax.params[pieceParts[0]] = pieceParts[1];
          }
        }

        this._selectizeLoadCallback = callback;
        this.$.coreAjax.params["query"] = query;
        this.$.coreAjax.params["page"] = 1;
        this.$.coreAjax.params["pageSize"] = 25;
        this.$.coreAjax.url = baseUrl;
        //this.$.coreAjax.params = {
        //  "query": query,
        //  "page": "1",
        //  "pageSize": "25"
        //};

        this.fire('at-form-lookup-beforeAjax', {
          coreAjax: this.$.coreAjax,
          query: query
        });
        this.$.coreAjax.noCredentials = this.noCredentials;
        this.$.coreAjax.generateRequest();
      }
    },

    _loadDefaultOnResponse: function(event) {
      var item = event.detail.Data;

      var irIndex;
      var irqLength = this._issuedRequestsQueue.length;
      var issuedRequest = null;
      
      // find the issued request in the queue by id
      for (irIndex = 0; irIndex < irqLength; irIndex++) {
        issuedRequest = this._issuedRequestsQueue[irIndex];
        if (issuedRequest.id === item.id) {
          break;
        }
      }
      if (!issuedRequest) { return; }

      // mark the request as completed and save the data from the server
      issuedRequest.isCompleted = true;
      issuedRequest.item = item;

      // check if all requests are complete
      var queueComplete = true;
      this._issuedRequestsQueue.forEach(function (request) {
        queueComplete = queueComplete && request.isCompleted;
      });

      if (!queueComplete) { return; }

      // process queue data into selectize instance
      var sInstance = this._selectizeInstance;
      this._issuedRequestsQueue.forEach(function (request, index) {

        sInstance.addOption({
          value: request.item.id,
          title: request.item.title
        });

        sInstance.addItem(request.item.id);
      });

      // clear the queue
      this._issuedRequestsQueue = [];

      this.$.disabledOverlay.removeAttribute('disabled');
      if (!this.disabled) {
        this._selectizeInstance.enable();
      }

      this.fire('at-form-lookup-initialized', {
        data: item
      });
    },

    _loadDefaultOnError: function (event) {
      this.$.disabledOverlay.removeAttribute('disabled');
      if (!this.disabled) {
        this._selectizeInstance.enable();
      }
    },

    _selectizeChange: function(newValue) {

      /* at-form-lookup has display mode of block and display mode of inline
        when display mode is inline lookup is about the size of its content 
        but when value is empty there is almost no content to wrap around so size is very small
        but very small lookup doesn't look like a lookup up at all and that you can select anything from it
        so in this special case we give input field width of 100px; in other cases we give it its original width of 4px;
        @see at-form-lookup-styles.html .inline-and-empty-width
      */
      (function(lookup, instance, value){
        // if at-form-lookup has display:inline-* and newValue is empty
        // give input field a special css class inline-and-empty-width
        // else remove it
        var displayValue = window.getComputedStyle(lookup).getPropertyValue('display');
        var isInline = /^inline/gi.test(displayValue);
        if (isInline && !value.length) {
          instance.$control_input.classList.add('inline-and-empty-width');
        } else {
          instance.$control_input.classList.remove('inline-and-empty-width');
        }
      })(this, this._selectizeInstance, newValue);

      this._selectizeUpdate = true;
      if (isArray(newValue)) {
        this.value = newValue.join(',');
      } else {
        this.value = newValue;
      }

      var selectedItemsIds = this._selectizeInstance.items;
      var allItems = this._selectizeInstance.options;
      var result = [];

      selectedItemsIds.forEach(function (id, index) {
        var item = allItems[id];
        if (item.title !== "" && item.value !== "") {
          result.push(item);
        }
      });
      this._setSelectedItems(result);

      this._selectizeUpdate = false;
      this._fireValueChangedEvent(this.value);
      this.fire('selected-items-changed', { value: this.selectedItems });
    },


    focus: function() {
      this._getFocusableElement().focus();
    },

    // this function is part of the hint/validation API
    // hint should be displayed when element gains focus
    // behavior can not know when element gained focus
    // but if gived focusable element it can attach to its focus event
    // it should return focusable element if available or null if focusable element doesn't exist
    _getFocusableElement: function () {
      var focusable = this.$.itemsView.$.filterTextInput;
      return focusable;
    }
  });

  function isArray(obj) {
    return Object.prototype.toString.call(obj) === "[object Array]";
  }

  function isString(obj) {
    return Object.prototype.toString.call(obj) === "[object String]";
  }

  function isCommaSeparated(obj) {
    return isString(obj) && obj.indexOf(',') !== -1;
  }

  /**
   * Computes the intersection of two arrays
   *
   * @param arr1-{array} first array
   * @param arr2-{array} second array
   * @return {array} intersection
   */
  function arrayIntersect(arr1, arr2) {
    var intersection = [];
    if (isArray(arr1) && isArray(arr2)) {
      for (var i = 0; i < arr1.length; i++) {
        if (arr2.indexOf(arr1[i]) != -1) {
          intersection.push(arr1[i]);
        }
      }
    }

    return intersection;
  }

  /**
   * Subtract itemsToSubtract array from subtractFrom array
   * Items from the itemsToSubtract are removed from subtractFrom array
   *
   * @param arr1-{array} subtractFrom
   * @param arr2-{array} itemsToSubtract
   * @return {array} subtraction
   */
  function arraySubtract(subtractFrom, itemsToSubtract) {
    var subtraction = [];

    if (isArray(subtractFrom) && isArray(itemsToSubtract)) {
      for (var i = 0; i < subtractFrom.length; i++) {
        if (itemsToSubtract.indexOf(subtractFrom[i]) == -1) {
          subtraction.push(subtractFrom[i]);
        }
      }
    }

    return subtraction;
  }

  /**
   * sifter.js
   * Copyright (c) 2013 Brian Reavis & contributors
   *
   * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this
   * file except in compliance with the License. You may obtain a copy of the License at:
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
   * ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   *
   * @author Brian Reavis <brian@thirdroute.com>
   */

  (function(root, factory) {
    "use strict";
    root.Sifter = factory();
  }(window.atFormLookup = window.atFormLookup || {}, function() {
    "use strict";

    // utilities
    //----------------------------------------

    var cmp = function(a, b) {
      if (typeof a === 'number' && typeof b === 'number') {
        return a > b ? 1 : (a < b ? -1 : 0);
      }
      a = String(a || '').toLowerCase();
      b = String(b || '').toLowerCase();
      if (a > b) {
        return 1;
      }
      if (b > a) {
        return -1;
      }
      return 0;
    };

    var extend = function(a, b) {
      var i, n, k, object;
      for (i = 1, n = arguments.length; i < n; i += 1) {
        object = arguments[i];
        if (!object) {
          continue;
        }
        for (k in object) {
          if (object.hasOwnProperty(k)) {
            a[k] = object[k];
          }
        }
      }
      return a;
    };

    var trim = function(str) {
      return String(str).replace(/^\s+|\s+$|/g, '');
    };

    var escape_regex = function(str) {
      return String(str).replace(/([.?*+^$[\]\\(){}|-])/g, '\\$1');
    };

    var is_array = Array.isArray || function(object) {
      return Object.prototype.toString.call(object) === '[object Array]';
    };

    var DIACRITICS = {
      'a': '[aÃ€ÃÃ‚ÃƒÃ„Ã…Ã Ã¡Ã¢Ã£Ã¤Ã¥Ä€Ä]',
      'c': '[cÃ‡Ã§Ä‡Ä†ÄÄŒ]',
      'd': '[dÄ‘ÄÄÄŽ]',
      'e': '[eÃˆÃ‰ÃŠÃ‹Ã¨Ã©ÃªÃ«Ä›ÄšÄ’Ä“]',
      'i': '[iÃŒÃÃŽÃÃ¬Ã­Ã®Ã¯ÄªÄ«]',
      'n': '[nÃ‘Ã±ÅˆÅ‡]',
      'o': '[oÃ’Ã“Ã”Ã•Ã•Ã–Ã˜Ã²Ã³Ã´ÃµÃ¶Ã¸ÅŒÅ]',
      'r': '[rÅ™Å˜]',
      's': '[sÅ Å¡]',
      't': '[tÅ¥Å¤]',
      'u': '[uÃ™ÃšÃ›ÃœÃ¹ÃºÃ»Ã¼Å¯Å®ÅªÅ«]',
      'y': '[yÅ¸Ã¿Ã½Ã]',
      'z': '[zÅ½Å¾]'
    };

    // export
    //----------------------------------------

    /**
     * Textually searches arrays and hashes of objects
     * by property (or multiple properties). Designed
     * specifically for autocomplete.
     *
     * @constructor
     * @param {array|object} items
     * @param {object} items
     */
    var Sifter = function(items, settings) {
      this.items = items;
      this.settings = settings || {
        diacritics: true
      };
    };

    /**
     * Splits a search string into an array of individual
     * regexps to be used to match results.
     *
     * @param {string} query
     * @returns {array}
     */
    Sifter.prototype.tokenize = function(query) {
      query = trim(String(query || '').toLowerCase());
      if (!query || !query.length) {
        return [];
      }

      var i, n, regex, letter,
        tokens = [],
        words = query.split(/ +/);

      for (i = 0, n = words.length; i < n; i += 1) {
        regex = escape_regex(words[i]);
        // if (this.settings.diacritics) {
        //   for (letter in DIACRITICS) {
        //     if (DIACRITICS.hasOwnProperty(letter)) {
        //       regex = regex.replace(new RegExp(letter, 'g'), DIACRITICS[letter]);
        //     }
        //   }
        // }
        tokens.push({
          string: words[i],
          regex: new RegExp(regex, 'i')
        });
      }

      return tokens;
    };

    /**
     * Iterates over arrays and hashes.
     *
     * ```
     * this.iterator(this.items, function(item, id) {
     *    // invoked for each item
     * });
     * ```
     *
     * @param {array|object} object
     */
    Sifter.prototype.iterator = function(object, callback) {
      var iterator, i, n;
      if (is_array(object)) {
        iterator = Array.prototype.forEach || function(callback) {
          for (i = 0, n = this.length; i < n; i += 1) {
            callback(this[i], i, this);
          }
        };
      } else {
        iterator = function(callback) {
          var key;
          for (key in this) {
            if (this.hasOwnProperty(key)) {
              callback(this[key], key, this);
            }
          }
        };
      }

      iterator.apply(object, [callback]);
    };

    /**
     * Returns a function to be used to score individual results.
     *
     * Good matches will have a higher score than poor matches.
     * If an item is not a match, 0 will be returned by the function.
     *
     * @param {object|string} search
     * @param {object} options (optional)
     * @returns {function}
     */
    Sifter.prototype.getScoreFunction = function(search, options) {
      var self, fields, tokens, token_count;

      self = this;
      search = self.prepareSearch(search, options);
      tokens = search.tokens;
      fields = search.options.fields;
      token_count = tokens.length;

      /**
       * Calculates how close of a match the
       * given value is against a search token.
       *
       * @param {mixed} value
       * @param {object} token
       * @return {number}
       */
      var scoreValue = function(value, token) {
        var score, pos;

        if (!value) {
          return 0;
        }
        value = String(value || '');
        pos = value.search(token.regex);
        if (pos === -1) {
          return 0;
        }
        score = token.string.length / value.length;
        if (pos === 0) {
          score += 0.5;
        }
        return score;
      };

      /**
       * Calculates the score of an object
       * against the search query.
       *
       * @param {object} token
       * @param {object} data
       * @return {number}
       */
      var scoreObject = (function() {
        var field_count = fields.length;
        if (!field_count) {
          return function() {
            return 0;
          };
        }
        if (field_count === 1) {
          return function(token, data) {
            return scoreValue(data[fields[0]], token);
          };
        }
        return function(token, data) {
          var i, sum;
          for (i = 0, sum = 0; i < field_count; i += 1) {
            sum += scoreValue(data[fields[i]], token);
          }
          return sum / field_count;
        };
      }());

      if (!token_count) {
        return function() {
          return 0;
        };
      }
      if (token_count === 1) {
        return function(data) {
          return scoreObject(tokens[0], data);
        };
      }

      if (search.options.conjunction === 'and') {
        return function(data) {
          var score, i, sum;
          for (i = 0, sum = 0; i < token_count; i += 1) {
            score = scoreObject(tokens[i], data);
            if (score <= 0) {
              return 0;
            }
            sum += score;
          }
          return sum / token_count;
        };
      } else {
        return function(data) {
          var i, sum;
          for (i = 0, sum = 0; i < token_count; i += 1) {
            sum += scoreObject(tokens[i], data);
          }
          return sum / token_count;
        };
      }
    };

    /**
     * Returns a function that can be used to compare two
     * results, for sorting purposes. If no sorting should
     * be performed, `null` will be returned.
     *
     * @param {string|object} search
     * @param {object} options
     * @return function(a,b)
     */
    Sifter.prototype.getSortFunction = function(search, options) {
      var i, n, self, field, fields, fields_count, multiplier, multipliers, get_field, implicit_score, sort;

      self = this;
      search = self.prepareSearch(search, options);
      sort = (!search.query && options.sort_empty) || options.sort;

      /**
       * Fetches the specified sort field value
       * from a search result item.
       *
       * @param  {string} name
       * @param  {object} result
       * @return {mixed}
       */
      get_field = function(name, result) {
        if (name === '$score') {
          return result.score;
        }
        return self.items[result.id][name];
      };

      // parse options
      fields = [];
      if (sort) {
        for (i = 0, n = sort.length; i < n; i += 1) {
          if (search.query || sort[i].field !== '$score') {
            fields.push(sort[i]);
          }
        }
      }

      // the "$score" field is implied to be the primary
      // sort field, unless it's manually specified
      if (search.query) {
        implicit_score = true;
        for (i = 0, n = fields.length; i < n; i += 1) {
          if (fields[i].field === '$score') {
            implicit_score = false;
            break;
          }
        }
        if (implicit_score) {
          fields.unshift({
            field: '$score',
            direction: 'desc'
          });
        }
      } else {
        for (i = 0, n = fields.length; i < n; i += 1) {
          if (fields[i].field === '$score') {
            fields.splice(i, 1);
            break;
          }
        }
      }

      multipliers = [];
      for (i = 0, n = fields.length; i < n; i += 1) {
        multipliers.push(fields[i].direction === 'desc' ? -1 : 1);
      }

      // build function
      fields_count = fields.length;
      if (!fields_count) {
        return null;
      } else if (fields_count === 1) {
        field = fields[0].field;
        multiplier = multipliers[0];
        return function(a, b) {
          return multiplier * cmp(
            get_field(field, a),
            get_field(field, b)
          );
        };
      } else {
        return function(a, b) {
          var i, result, a_value, b_value, field;
          for (i = 0; i < fields_count; i += 1) {
            field = fields[i].field;
            result = multipliers[i] * cmp(
              get_field(field, a),
              get_field(field, b)
            );
            if (result) {
              return result;
            }
          }
          return 0;
        };
      }
    };

    /**
     * Parses a search query and returns an object
     * with tokens and fields ready to be populated
     * with results.
     *
     * @param {string} query
     * @param {object} options
     * @returns {object}
     */
    Sifter.prototype.prepareSearch = function(query, options) {
      if (typeof query === 'object') {
        return query;
      }

      options = extend({}, options);

      var option_fields = options.fields;
      var option_sort = options.sort;
      var option_sort_empty = options.sort_empty;

      if (option_fields && !is_array(option_fields)) {
        options.fields = [option_fields];
      }
      if (option_sort && !is_array(option_sort)) {
        options.sort = [option_sort];
      }
      if (option_sort_empty && !is_array(option_sort_empty)) {
        options.sort_empty = [option_sort_empty];
      }

      return {
        options: options,
        query: String(query || '').toLowerCase(),
        tokens: this.tokenize(query),
        total: 0,
        items: []
      };
    };

    /**
     * Searches through all items and returns a sorted array of matches.
     *
     * The `options` parameter can contain:
     *
     *  -fields {string|array}
     *  -sort {array}
     *  -score {function}
     *  -filter {bool}
     *  -limit {integer}
     *
     * Returns an object containing:
     *
     *  -options {object}
     *  -query {string}
     *  -tokens {array}
     *  -total {int}
     *  -items {array}
     *
     * @param {string} query
     * @param {object} options
     * @returns {object}
     */
    Sifter.prototype.search = function(query, options) {
      var self = this,
        value,
        score,
        search,
        calculateScore,
        fn_sort,
        fn_score;

      search = this.prepareSearch(query, options);
      options = search.options;
      query = search.query;

      // generate result scoring function
      fn_score = options.score || self.getScoreFunction(search);

      // perform search and sort
      if (query.length) {
        self.iterator(self.items, function(item, id) {
          score = fn_score(item);
          if (options.filter === false || score > 0) {
            search.items.push({
              'score': score,
              'id': id
            });
          }
        });
      } else {
        self.iterator(self.items, function(item, id) {
          search.items.push({
            'score': 1,
            'id': id
          });
        });
      }

      fn_sort = self.getSortFunction(search, options);
      if (fn_sort) {
        search.items.sort(fn_sort);
      }

      // apply limits
      search.total = search.items.length;
      if (typeof options.limit === 'number') {
        search.items = search.items.slice(0, options.limit);
      }

      return search;
    };

    return Sifter;
  }));

</script>
