<link rel="import" href="../polymer/polymer.html" />
<link rel="import" href="../at-theme/at-theme.html">
<link rel="import" href="../at-core-activity/at-core-activity.html" />
<link rel="import" href="../at-carbon-icon/at-carbon-icon.html" />
<link rel="import" href="../paper-shadow/paper-shadow.html" />
<link rel="import" href="../at-form-behaviors/at-form-behaviors-validation.html">
<link rel="import" href="at-form-lookup-styles.html">
<link rel="import" href="../iron-label/iron-label.html">

  <script type="text/javascript">
  var SelectBoxUtils = {
    breakBinding: function(func, marker) {
      marker = marker || "dontBind";
      return function() {
        if (!this[marker]) {
          this[marker] = true;
          func.apply(this, arguments);
          Platform.flush();
          this.async(function() {
            this[marker] = false;
          });
        }
      }
    }
  };
</script>

<dom-module id="at-form-lookup">
  <template>
    <style include="at-form-common"></style>
    <style include="at-form-lookup-styles"></style>
    <style>
      :host * {
        box-sizing: border-box;
      }

      :host {
        @apply(--at-form-host);
      }

      .input {
        @apply(--at-form-input-common);
      }

      #contentContainer {
        position: relative;;
      }

      #contentContainer.error .input {
        @apply(--at-form-content-error);
      }

      #disabledOverlay {
        display: none;
      }

      #disabledOverlay[disabled] {
        display: flex;
        flex-direction: row;
        position: absolute;
        bottom: 0px;
        width: 100%;
        z-index: 99999;
        height: 100%;
      }

      #disabledText {
        text-align: center;
        align-self: center;
        flex: 1;
      }
    </style>
    <div id="atContainer" class="at-container">
      <iron-label id="label" for="selectTags" class="at-label">{{label}}</iron-label>
      <div id="contentContainer" class="at-content-container">
        <!--<input id="inputTags" type="text" value="{{available}}" style="display:none" />-->
        <select id="selectTags" style="display:none"></select>
        <at-core-activity id="coreAjax" handle-as="json" url="{{url}}" params="{{params}}" on-response="coreAjaxOnResponse" on-complete="coreAjaxOnComplete"></at-core-activity>
        <div id="disabledOverlay">
          <div id="disabledText">Loading...</div>
        </div>
      </div>
      <div id="hint" class="hint"></div>
    </div>
  </template>
</dom-module>
<script>
  'use strict';

  function isArray(obj) {
    return Object.prototype.toString.call(obj) === Object.prototype.toString.call([]);
  }

  function isCommaSeparated(obj) {
    return obj !== undefined && obj.indexOf !== undefined && obj.indexOf(',') !== -1;
  }

  Polymer({
    is: 'at-form-lookup',
    behaviors: [AtFormBehaviors.AtFormBehaviorsValidation],
    _selectizeLoadCallback: false,
    _selectizeInstance: {},
    _isUpdating: false,
    _isReady: false,
    render: {},
    properties: {
      disabled: {
        type: Boolean,
        value: false,
        observer: 'disabledChanged'
      },
      required: {
        type: Boolean,
        value: false,
        observer: 'requiredChanged'
      },
      /**
       * the list of items that should initially be present for selection
       */
      available: {
        type: String,
        value: '',
        observer: 'availableChanged'
      },
      // ------------------------------------------------------------
      // "Why is xvaluelist here?" - you ask.
      // "We already have available just above" - you say.
      // xvaluelist is here to improve compatibility with copyProperties function in at-core-form/script/schema-helpers.js
      // this function goes through element properties and copies property values from property definition in json schema to element properties
      // now available doens't exist in property definition in json schema so undefined will be copied
      // xvaluelist exists in json schema and when property name is valuelist, xvaluelist should be copied
      // so we introduce xvaluelist property in at-form-radio to remove if statement that would detect this situation
      // ------------------------------------------------------------
      xvaluelist: {
        type: Array,
        value: function() {
          return [];
        },
        observer: 'availableChanged',
        schema: {
          items: {
            type: "object",
            properties: {
              title: {
                "type": "string"
              },
              value: {
                type: "string"
              }
            }
          }
        },
        layout: 'horizontal'
      },
      // ------------------------------------------------------------
      // "Why is enum here?" - you ask.
      // "We already have available and xvaluelist just above" - you say.
      // read explanation for xvaluelist, enum is here for the same reason
      // ------------------------------------------------------------
      enum: {
        type: Array,
        value: function() {
          return [];
        },
        observer: 'availableChanged',
        schema: {
          items: {
            type: "string",
            properties: {
              value: {
                type: "string"
              }
            }
          }
        },
        layout: 'horizontal'
      },
      value: {
        type: String,
        value: '',
        observer: 'valueChanged'
      },
      selectedItems: {
        type: Array,
        value: function () {
          return [];
        },
        xtype: 'json',
        readOnly: true
      },
      label: {
        type: String,
        value: ''
      },
      noCredentials: {
        type: Boolean,
        value: false
      },
      /**
       * allows to create new entries when no matching record is found
       */
      allowNewItems: {
        type: Boolean,
        value: false,
        observer: 'allowNewItemsChanged'
      },
      noPreload: {
        type: Boolean,
        value: false
      },
      url: {
        type: String,
        value: '',
        observer: 'urlChanged'
      },
      xurl: {
        type: String,
        value: '',
        observer: 'xurlChanged'
      },
      params: {
        type: String,
        value: '',
        observer: 'paramsChanged'
      },
      maxItems: {
        type: Number,
        value: 1,
        observer: 'maxItemsChanged'
      },
      hideLabel: {
        type: Boolean,
        value: false,
        observer: 'hideLabelChanged'
      },
      /**
       * Hides the element. When hidden nothing is displayed for the element
       * @property hide
       * @type Boolean
       * @default false
       */
      hide: {
        type: Boolean,
        value: false,
        observer: 'hideChanged'
      }
    },
    $meta: [{
      title: "Enum",
      type: "string",
      xtype: "enum"
    }, {
      title: "Lookup",
      type: "string",
      xtype: "lookup"
    }],
    set selectedItems(newValue) {},
    maxItemsChanged: function(newValue, oldValue) {
      if (this._isReady && this._selectizeInstance) {
        try {
          var valueToSet = Number(newValue);
          var settings = this._selectizeInstance.settings;
          settings.maxItems = valueToSet;
          var mode = valueToSet === 1 ? 'single' : 'multi';
          var prevMode = settings.mode;
          settings.mode = mode;
          settings.hideSelected = mode === 'multi';
          var wrapper = this._selectizeInstance.$wrapper;
          Polymer.dom(wrapper).classList.remove(prevMode);
          Polymer.dom(wrapper).classList.add(mode);
          var dropdown = this._selectizeInstance.$dropdown;
          Polymer.dom(dropdown).classList.remove(prevMode);
          Polymer.dom(dropdown).classList.add(mode);
        } catch (e) {
          console.log(e);
        }
      }
    },
    hideLabelChanged: function(newValue, oldValue) {
      this.toggleClass("hidden", newValue, this.$.label);
    },
    renderChanged: function(newValue, oldValue) {
      if (this._selectizeInstance !== undefined) {
        this._selectizeInstance.settings.render = extend({}, this._selectizeInstance.settings.render, newValue);
      }
    },

    labelChanged: function(newValue, oldValue) {
      this.$.label.textContent = newValue;
    },

    paramsChanged: function() {
      if (this._isReady) {
        this.noPreload = true;
        if (this.params !== '') {
          this.noPreload = false;
        }
        this.requestParamsChanged();
      }
    },

    xurlChanged: function(newValue) {
      // xurl is now mapped to url
      if (newValue != this.url) {
        this.url = newValue;
      }
    },

    urlChanged: function(newValue, oldValue) {
      if (this._isReady) {
        this.noPreload = true;
        if (this.url !== '') {
          this.noPreload = false;
        }

        this.requestParamsChanged();
        // AT-32 when value is set before url, that value needs to be displayed
        this.valueChanged(this.value, this.value);
      }
      this.xurl = this.url; // update legacy xurl parameter
    },
    // this function is here to improve compatibility with form designer
    xvaluelistChanged: function(newValue, oldValue) {
      this.availableChanged(newValue, oldValue);
    },
    availableChanged: function(newValue, oldValue) {
      var i;

      if (this._isReady) {
        var instance = this._selectizeInstance;
        // *ij* this setting prevents unnecessary change event
        // which clears the current valid at-form-lookup value
        instance.isInitializing = true;
        instance.clearOptions();
        instance.isInitializing = false;

        if (isArray(newValue)) {
          for (i = 0; i < newValue.length; i += 1) {
            var option = newValue[i];
            if (isString(option)) {
              option = option.trim();
              instance.addOption({
                value: option,
                title: option
              });
            } else if (!option.title) {
              option.title = option.value;
              instance.addOption(option);
            } else {
              instance.addOption(option);
            }
          }
          instance.addOption(newValue);
        } else if (isCommaSeparated(newValue)) {
          var items = newValue.split(',');
          for (i = 0; i < items.length; i += 1) {
            var newOption = {
              value: items[i].trim(),
              title: items[i].trim()
            };
            instance.addOption(newOption);
          }
        }

        if (instance.options.hasOwnProperty(this.value)) {
          instance.addItem(this.value);
        }
      }
    },

    valueChanged: function(newValue, oldValue) {
      if (this._isReady) {
        if (!this._isUpdating && !this._selectizeUpdate) {
          this._isUpdating = true;

          // do the update
          var sInstance = this._selectizeInstance;

          var newValues = this.value;
          if (!isArray(this.value)) {

            if (this.value.length <= 0) {
              newValues = new Array();
            } else {
              newValues = this.value.split(',');
            }
          }

          var selectedItems = sInstance.items;

          var arrIntersection = arrayIntersect(newValues, selectedItems);
          var itemsToAdd = arraySubtract(newValues, arrIntersection);
          var itemsToRemove = arraySubtract(selectedItems, arrIntersection);

          for (var i = 0; i < itemsToRemove.length; i++) {
            sInstance.removeItem(itemsToRemove[i]);
          }

          for (var i = 0; i < itemsToAdd.length; i++) {
            var currentItem = itemsToAdd[i];

            if (sInstance.options.hasOwnProperty(currentItem)) {
              sInstance.addItem(currentItem);
            } else {
              if (this.url !== "" && currentItem !== "") {
                // *ij* this here is request by *ma*
                // at-form-lookup should work in orchard without any additional configuration
                // code bellow makes that possible
                // component is first disabled so user can't input
                this._selectizeInstance.disable();
                // an disabled overlay is "displayed"
                Polymer.dom(this.$.disabledOverlay).setAttribute('disabled', true);
                // a correct url is constructed
                var urlParts = this.url.split('?');
                var baseUrl = urlParts[0];
                var queryPart = urlParts.length > 1 ? '?' + urlParts[1] : '';
                var coreActivity = document.createElement('at-core-activity');
                coreActivity.handleAs = 'json';
                var finalUrl = baseUrl + '/' + currentItem + queryPart;
                coreActivity.url = finalUrl;
                // noCredentials parameter is set on the ajax component
                coreActivity.noCredentials = this.noCredentials;
                // add listener for response event
                coreActivity.addEventListener('response', this.loadDefaultOnResponse.bind(this));
                // request is made
                coreActivity.generateRequest();
              }
            }
          }

          this._isUpdating = false;
          this._selectizeUpdate = false;
        }
        this.validate();
      }
    },

    requestParamsChanged: function() {
      if (this._selectizeInstance.clear && this._selectizeInstance.clearOptions) {
        this._selectizeInstance.clear();
        this._selectizeInstance.clearOptions();
        this._selectizeInstance.onSearchChange('');
      }
    },

    ready: function() {
      this.initialize();
      this._validationFunctions.push(this._isValueValidForXValueList.bind(this));
      this._attachFocusBlurEvents();
    },

    _isValueValidForXValueList: function(value) {
      var valueList = this.xvaluelist;
      var result = true;

      if (typeof valuelist == "undefined" || valueList.length < 1) {
        return true;
      }
      if (value === '') {
        return true;
      }

      var valuesToCheck = value.split(',');

      if (isString(valueList)) {
        valueList = valueList.split(',');
      }

      valuesToCheck.forEach(function(valueToCheck, index) {
        var localResult = false;
        valueList.forEach(function(item, index) {
          if (item.value) {
            localResult = localResult || item.value === valueToCheck;
          } else {
            localResult = localResult || item === valueToCheck;
          }
        });
        result = result && localResult;
      });

      if (!result) {
        this._errorMessage = 'Value ' + value + ' is invalid.';
      }

      return result;
    },

    set valid(newValue) {},

    _updateUIValidState: function(isValid) {
      var label = this.$.label;
      this.toggleClass('error', !isValid, label);
      var contentContainer = this.$.contentContainer;
      this.toggleClass('error', !isValid, contentContainer);
    },

    requiredChanged: function(newValue, oldValue) {
      if (this._isReady) {
        this.validate();
      }
    },

    disabledChanged: function(newValue, oldValue) {
      if (this._isReady && this._selectizeInstance !== undefined) {
        var atContainer = this.$.atContainer;
        this.toggleClass('disabled', newValue, atContainer);

        if (newValue) {
          this._selectizeInstance.disable();
        } else {
          this._selectizeInstance.enable();
        }

        this.validate();
      }
    },

    hideChanged: function(newValue, oldValue) {
      var wrapper = this.$.atContainer;
      this.toggleClass('hidden', newValue, wrapper);
      if (this._isReady) {
        this.validate();
      }
    },

    destroyExisting: function() {
      if (this.$.selectTags.selectize) {
        this.$.selectTags.selectize.destroy();
        this.$.selectTags.style.display = "none";
      }
      if (this.$.inputTags.selectize) {
        this.$.inputTags.selectize.destroy();
        this.$.inputTags.style.display = "none";
      }
    },

    coreAjaxOnComplete: function(event) {
      this.$.disabledOverlay.removeAttribute('disabled');
      this._selectizeInstance.enable();
    },

    coreAjaxOnResponse: function(event) {
      // extract the data from the event
      var eventObject = {
        response: event.detail,
        returnData: []
      };
      this.fire('at-form-lookup-afterAjax', eventObject);

      if (this._selectizeLoadCallback) {
        if (eventObject.returnData.length > 0) {
          this._selectizeLoadCallback(eventObject.returnData);
        } else {
          var data = [];
          if (event.detail && (event.detail.Data !== undefined && event.detail.Data !== null) && (event.detail.Data.items !== undefined && event.detail.Data.items !== null)) {
            data = event.detail.Data.items;
          }
          var dataArray = [];
          for (var i = 0; i < data.length; i++) {
            var entry = data[i];
            entry.value = entry.id;
            //dataArray.push({ value: entry.id, title: entry.title });
            dataArray.push(entry);
          }
          this._selectizeLoadCallback(dataArray);
        }
      };
    },

    selectizeOnLoad: function(query, callback) {
      // this here is selectize object
      // polymer element upon which selectize is constructed is passed into selectize settings and can be accessed here
      if (this.url !== '') {

        this.$.coreAjax.params = {};

        var urlParts = this.url.split('?');
        var baseUrl = urlParts[0];
        var queryPart = urlParts.length > 1 ? urlParts[1] : '';

        var queryPieces = queryPart.split('&');
        var index;
        for (index = 0; index < queryPieces.length; index++) {
          var queryPiece = queryPieces[index];
          var pieceParts = queryPiece.split('=');
          if (pieceParts.length && pieceParts.length === 2) {
            this.$.coreAjax.params[pieceParts[0]] = pieceParts[1];
          }
        }

        this._selectizeLoadCallback = callback;
        this.$.coreAjax.params["query"] = query;
        this.$.coreAjax.params["page"] = 1;
        this.$.coreAjax.params["pageSize"] = 25;
        this.$.coreAjax.url = baseUrl;
        //this.$.coreAjax.params = {
        //  "query": query,
        //  "page": "1",
        //  "pageSize": "25"
        //};

        this.fire('at-form-lookup-beforeAjax', {
          coreAjax: this.$.coreAjax,
          query: query
        });
        this.$.coreAjax.noCredentials = this.noCredentials;
        this.$.coreAjax.generateRequest();
      }
    },

    loadDefaultOnResponse: function(event) {
      var item = event.detail.Data;
      this._selectizeInstance.addOption({
        "value": item.id,
        "title": item.title
      });
      this._selectizeInstance.addItem(item.id);

      this.$.disabledOverlay.removeAttribute('disabled');
      this._selectizeInstance.enable();

      this.fire('at-form-lookup-initialized', {
        data: item
      });
    },

    selectizeChange: function(newValue) {
      this._selectizeUpdate = true;
      if (isArray(newValue)) {
        this.value = newValue.join(',');
      } else {
        this.value = newValue;
      }

      var selectedItemsIds = this._selectizeInstance.items;
      var allItems = this._selectizeInstance.options;
      var result = [];

      selectedItemsIds.forEach(function (id, index) {
        var item = allItems[id];
        result.push(item);
      });
      this._setSelectedItems(result);

      this._selectizeUpdate = false;
      this.fire('value-changed', { value: this.value });
      this.fire('selected-items-changed', { value: this.selectedItems });
    },

    initialize: function() {

      // create the selectize instance
      var instance = this._selectizeInstance = window.atFormLookup.selectize(this.$.selectTags, {
        plugins: ['remove_button'],
        create: this.allowNewItems,
        selectOnTab: true,
        preload: !this.noPreload,
        allowEmpty: this.allowEmpty,
        maxItems: this.maxItems,
        load: this.selectizeOnLoad.bind(this),
        onChange: this.selectizeChange.bind(this),
        render: this.render
      });

      // NOT NEEDED clear options and items from from instance

      // initialzie the component
      // maxItems = 1 => show dropdown icon; maxItems > 1 do not show dropdown icon

      // set disabled state
      if (this.disabled) {
        instance.disable();
      }

      this._isReady = true;

      // set available options
      this.availableChanged(this.available, []);

      // set items selected by default
      this.valueChanged(this.value, []);
    },
    allowNewItemsChanged: function(newValue, oldValue) {
      if (this._isReady && this._selectizeInstance) {
        var valueToSet = Boolean(newValue);
        this._selectizeInstance.settings.create = valueToSet;
      }
    },
    focus: function() {
      if (this._selectizeInstance) {
        this._selectizeInstance.focus(true);
      }
    },
    // this function is part of the hint/validation API
    // hint should be displayed when element gains focus
    // behavior can not know when element gained focus
    // but if gived focusable element it can attach to its focus event
    // it should return focusable element if available or null if focusable element doesn't exist
    _getFocusableElement: function () {
      var focusable = this.$$('.control input');
      return focusable;
    }
  });

  function isArray(obj) {
    return Object.prototype.toString.call(obj) === "[object Array]";
  }

  function isString(obj) {
    return Object.prototype.toString.call(obj) === "[object String]";
  }

  /**
   * Computes the intersection of two arrays
   *
   * @param arr1-{array} first array
   * @param arr2-{array} second array
   * @return {array} intersection
   */
  function arrayIntersect(arr1, arr2) {
    var intersection = [];
    if (isArray(arr1) && isArray(arr2)) {
      for (var i = 0; i < arr1.length; i++) {
        if (arr2.indexOf(arr1[i]) != -1) {
          intersection.push(arr1[i]);
        }
      }
    }

    return intersection;
  }

  /**
   * Subtract itemsToSubtract array from subtractFrom array
   * Items from the itemsToSubtract are removed from subtractFrom array
   *
   * @param arr1-{array} subtractFrom
   * @param arr2-{array} itemsToSubtract
   * @return {array} subtraction
   */
  function arraySubtract(subtractFrom, itemsToSubtract) {
    var subtraction = [];

    if (isArray(subtractFrom) && isArray(itemsToSubtract)) {
      for (var i = 0; i < subtractFrom.length; i++) {
        if (itemsToSubtract.indexOf(subtractFrom[i]) == -1) {
          subtraction.push(subtractFrom[i]);
        }
      }
    }

    return subtraction;
  }

  (function(ns) {
    var hashTable = {};

    ns.data = function(object, key) {
      var pair = hashTable[object];
      return pair && pair[key];
    }

    ns.data = function(object, key, value) {
      var pair = hashTable[object];
      if (pair) {
        var oldValue = pair[key];
        pair[key] = value;
        return oldValue;
      } else {
        pair = {};
        pair[key] = value;
        hashTable[object] = pair;
        return value;
      }
    }

    ns.removeData = function(object, key) {
      var pair = hashTable[object];
      delete pair[key];
    }
  }(window.atFormLookup = window.atFormLookup || {}));

  /**
   * microplugin.js
   * Copyright (c) 2013 Brian Reavis & contributors
   *
   * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this
   * file except in compliance with the License. You may obtain a copy of the License at:
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
   * ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   *
   * @author Brian Reavis <brian@thirdroute.com>
   */

  (function(root, factory) {
    "use strict";
    root.MicroPlugin = factory();
  }(window.atFormLookup = window.atFormLookup || {}, function() {
    "use strict";

    var utils = {
      isArray: Array.isArray || function(vArg) {
        return Object.prototype.toString.call(vArg) === '[object Array]';
      }
    };

    var MicroPlugin = {};

    MicroPlugin.mixin = function(Interface) {
      Interface.plugins = {};

      /**
       * Initializes the listed plugins (with options).
       * Acceptable formats:
       *
       * List (without options):
       *   ['a', 'b', 'c']
       *
       * List (with options):
       *   [{'name': 'a', options: {}}, {'name': 'b', options: {}}]
       *
       * Hash (with options):
       *   {'a': { ... }, 'b': { ... }, 'c': { ... }}
       *
       * @param {mixed} plugins
       */
      Interface.prototype.initializePlugins = function(plugins) {
        var i, n, key;
        var self = this;
        var queue = [];

        self.plugins = {
          names: [],
          settings: {},
          requested: {},
          loaded: {}
        };

        if (utils.isArray(plugins)) {
          for (i = 0, n = plugins.length; i < n; i += 1) {
            if (typeof plugins[i] === 'string') {
              queue.push(plugins[i]);
            } else {
              self.plugins.settings[plugins[i].name] = plugins[i].options;
              queue.push(plugins[i].name);
            }
          }
        } else if (plugins) {
          for (key in plugins) {
            if (plugins.hasOwnProperty(key)) {
              self.plugins.settings[key] = plugins[key];
              queue.push(key);
            }
          }
        }

        while (queue.length) {
          self.require(queue.shift());
        }
      };

      Interface.prototype.loadPlugin = function(name) {
        var self = this;
        var plugins = self.plugins;
        var plugin = Interface.plugins[name];

        if (!Interface.plugins.hasOwnProperty(name)) {
          throw new Error('Unable to find "' + name + '" plugin');
        }

        plugins.requested[name] = true;
        plugins.loaded[name] = plugin.fn.apply(self, [self.plugins.settings[name] || {}]);
        plugins.names.push(name);
      };

      /**
       * Initializes a plugin.
       *
       * @param {string} name
       */
      Interface.prototype.require = function(name) {
        var self = this;
        var plugins = self.plugins;

        if (!self.plugins.loaded.hasOwnProperty(name)) {
          if (plugins.requested[name]) {
            throw new Error('Plugin has circular dependency ("' + name + '")');
          }
          self.loadPlugin(name);
        }

        return plugins.loaded[name];
      };

      /**
       * Registers a plugin.
       *
       * @param {string} name
       * @param {function} fn
       */
      Interface.define = function(name, fn) {
        Interface.plugins[name] = {
          'name': name,
          'fn': fn
        };
      };
    };

    return MicroPlugin;
  }));

  /**
   * sifter.js
   * Copyright (c) 2013 Brian Reavis & contributors
   *
   * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this
   * file except in compliance with the License. You may obtain a copy of the License at:
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
   * ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   *
   * @author Brian Reavis <brian@thirdroute.com>
   */

  (function(root, factory) {
    "use strict";
    root.Sifter = factory();
  }(window.atFormLookup = window.atFormLookup || {}, function() {
    "use strict";

    // utilities
    //----------------------------------------

    var cmp = function(a, b) {
      if (typeof a === 'number' && typeof b === 'number') {
        return a > b ? 1 : (a < b ? -1 : 0);
      }
      a = String(a || '').toLowerCase();
      b = String(b || '').toLowerCase();
      if (a > b) {
        return 1;
      }
      if (b > a) {
        return -1;
      }
      return 0;
    };

    var extend = function(a, b) {
      var i, n, k, object;
      for (i = 1, n = arguments.length; i < n; i += 1) {
        object = arguments[i];
        if (!object) {
          continue;
        }
        for (k in object) {
          if (object.hasOwnProperty(k)) {
            a[k] = object[k];
          }
        }
      }
      return a;
    };

    var trim = function(str) {
      return String(str).replace(/^\s+|\s+$|/g, '');
    };

    var escape_regex = function(str) {
      return String(str).replace(/([.?*+^$[\]\\(){}|-])/g, '\\$1');
    };

    var is_array = Array.isArray || function(object) {
      return Object.prototype.toString.call(object) === '[object Array]';
    };

    var DIACRITICS = {
      'a': '[aÃ€ÃÃ‚ÃƒÃ„Ã…Ã Ã¡Ã¢Ã£Ã¤Ã¥Ä€Ä]',
      'c': '[cÃ‡Ã§Ä‡Ä†ÄÄŒ]',
      'd': '[dÄ‘ÄÄÄŽ]',
      'e': '[eÃˆÃ‰ÃŠÃ‹Ã¨Ã©ÃªÃ«Ä›ÄšÄ’Ä“]',
      'i': '[iÃŒÃÃŽÃÃ¬Ã­Ã®Ã¯ÄªÄ«]',
      'n': '[nÃ‘Ã±ÅˆÅ‡]',
      'o': '[oÃ’Ã“Ã”Ã•Ã•Ã–Ã˜Ã²Ã³Ã´ÃµÃ¶Ã¸ÅŒÅ]',
      'r': '[rÅ™Å˜]',
      's': '[sÅ Å¡]',
      't': '[tÅ¥Å¤]',
      'u': '[uÃ™ÃšÃ›ÃœÃ¹ÃºÃ»Ã¼Å¯Å®ÅªÅ«]',
      'y': '[yÅ¸Ã¿Ã½Ã]',
      'z': '[zÅ½Å¾]'
    };

    // export
    //----------------------------------------

    /**
     * Textually searches arrays and hashes of objects
     * by property (or multiple properties). Designed
     * specifically for autocomplete.
     *
     * @constructor
     * @param {array|object} items
     * @param {object} items
     */
    var Sifter = function(items, settings) {
      this.items = items;
      this.settings = settings || {
        diacritics: true
      };
    };

    /**
     * Splits a search string into an array of individual
     * regexps to be used to match results.
     *
     * @param {string} query
     * @returns {array}
     */
    Sifter.prototype.tokenize = function(query) {
      query = trim(String(query || '').toLowerCase());
      if (!query || !query.length) {
        return [];
      }

      var i, n, regex, letter,
        tokens = [],
        words = query.split(/ +/);

      for (i = 0, n = words.length; i < n; i += 1) {
        regex = escape_regex(words[i]);
        if (this.settings.diacritics) {
          for (letter in DIACRITICS) {
            if (DIACRITICS.hasOwnProperty(letter)) {
              regex = regex.replace(new RegExp(letter, 'g'), DIACRITICS[letter]);
            }
          }
        }
        tokens.push({
          string: words[i],
          regex: new RegExp(regex, 'i')
        });
      }

      return tokens;
    };

    /**
     * Iterates over arrays and hashes.
     *
     * ```
     * this.iterator(this.items, function(item, id) {
     *    // invoked for each item
     * });
     * ```
     *
     * @param {array|object} object
     */
    Sifter.prototype.iterator = function(object, callback) {
      var iterator, i, n;
      if (is_array(object)) {
        iterator = Array.prototype.forEach || function(callback) {
          for (i = 0, n = this.length; i < n; i += 1) {
            callback(this[i], i, this);
          }
        };
      } else {
        iterator = function(callback) {
          var key;
          for (key in this) {
            if (this.hasOwnProperty(key)) {
              callback(this[key], key, this);
            }
          }
        };
      }

      iterator.apply(object, [callback]);
    };

    /**
     * Returns a function to be used to score individual results.
     *
     * Good matches will have a higher score than poor matches.
     * If an item is not a match, 0 will be returned by the function.
     *
     * @param {object|string} search
     * @param {object} options (optional)
     * @returns {function}
     */
    Sifter.prototype.getScoreFunction = function(search, options) {
      var self, fields, tokens, token_count;

      self = this;
      search = self.prepareSearch(search, options);
      tokens = search.tokens;
      fields = search.options.fields;
      token_count = tokens.length;

      /**
       * Calculates how close of a match the
       * given value is against a search token.
       *
       * @param {mixed} value
       * @param {object} token
       * @return {number}
       */
      var scoreValue = function(value, token) {
        var score, pos;

        if (!value) {
          return 0;
        }
        value = String(value || '');
        pos = value.search(token.regex);
        if (pos === -1) {
          return 0;
        }
        score = token.string.length / value.length;
        if (pos === 0) {
          score += 0.5;
        }
        return score;
      };

      /**
       * Calculates the score of an object
       * against the search query.
       *
       * @param {object} token
       * @param {object} data
       * @return {number}
       */
      var scoreObject = (function() {
        var field_count = fields.length;
        if (!field_count) {
          return function() {
            return 0;
          };
        }
        if (field_count === 1) {
          return function(token, data) {
            return scoreValue(data[fields[0]], token);
          };
        }
        return function(token, data) {
          var i, sum;
          for (i = 0, sum = 0; i < field_count; i += 1) {
            sum += scoreValue(data[fields[i]], token);
          }
          return sum / field_count;
        };
      }());

      if (!token_count) {
        return function() {
          return 0;
        };
      }
      if (token_count === 1) {
        return function(data) {
          return scoreObject(tokens[0], data);
        };
      }

      if (search.options.conjunction === 'and') {
        return function(data) {
          var score, i, sum;
          for (i = 0, sum = 0; i < token_count; i += 1) {
            score = scoreObject(tokens[i], data);
            if (score <= 0) {
              return 0;
            }
            sum += score;
          }
          return sum / token_count;
        };
      } else {
        return function(data) {
          var i, sum;
          for (i = 0, sum = 0; i < token_count; i += 1) {
            sum += scoreObject(tokens[i], data);
          }
          return sum / token_count;
        };
      }
    };

    /**
     * Returns a function that can be used to compare two
     * results, for sorting purposes. If no sorting should
     * be performed, `null` will be returned.
     *
     * @param {string|object} search
     * @param {object} options
     * @return function(a,b)
     */
    Sifter.prototype.getSortFunction = function(search, options) {
      var i, n, self, field, fields, fields_count, multiplier, multipliers, get_field, implicit_score, sort;

      self = this;
      search = self.prepareSearch(search, options);
      sort = (!search.query && options.sort_empty) || options.sort;

      /**
       * Fetches the specified sort field value
       * from a search result item.
       *
       * @param  {string} name
       * @param  {object} result
       * @return {mixed}
       */
      get_field = function(name, result) {
        if (name === '$score') {
          return result.score;
        }
        return self.items[result.id][name];
      };

      // parse options
      fields = [];
      if (sort) {
        for (i = 0, n = sort.length; i < n; i += 1) {
          if (search.query || sort[i].field !== '$score') {
            fields.push(sort[i]);
          }
        }
      }

      // the "$score" field is implied to be the primary
      // sort field, unless it's manually specified
      if (search.query) {
        implicit_score = true;
        for (i = 0, n = fields.length; i < n; i += 1) {
          if (fields[i].field === '$score') {
            implicit_score = false;
            break;
          }
        }
        if (implicit_score) {
          fields.unshift({
            field: '$score',
            direction: 'desc'
          });
        }
      } else {
        for (i = 0, n = fields.length; i < n; i += 1) {
          if (fields[i].field === '$score') {
            fields.splice(i, 1);
            break;
          }
        }
      }

      multipliers = [];
      for (i = 0, n = fields.length; i < n; i += 1) {
        multipliers.push(fields[i].direction === 'desc' ? -1 : 1);
      }

      // build function
      fields_count = fields.length;
      if (!fields_count) {
        return null;
      } else if (fields_count === 1) {
        field = fields[0].field;
        multiplier = multipliers[0];
        return function(a, b) {
          return multiplier * cmp(
            get_field(field, a),
            get_field(field, b)
          );
        };
      } else {
        return function(a, b) {
          var i, result, a_value, b_value, field;
          for (i = 0; i < fields_count; i += 1) {
            field = fields[i].field;
            result = multipliers[i] * cmp(
              get_field(field, a),
              get_field(field, b)
            );
            if (result) {
              return result;
            }
          }
          return 0;
        };
      }
    };

    /**
     * Parses a search query and returns an object
     * with tokens and fields ready to be populated
     * with results.
     *
     * @param {string} query
     * @param {object} options
     * @returns {object}
     */
    Sifter.prototype.prepareSearch = function(query, options) {
      if (typeof query === 'object') {
        return query;
      }

      options = extend({}, options);

      var option_fields = options.fields;
      var option_sort = options.sort;
      var option_sort_empty = options.sort_empty;

      if (option_fields && !is_array(option_fields)) {
        options.fields = [option_fields];
      }
      if (option_sort && !is_array(option_sort)) {
        options.sort = [option_sort];
      }
      if (option_sort_empty && !is_array(option_sort_empty)) {
        options.sort_empty = [option_sort_empty];
      }

      return {
        options: options,
        query: String(query || '').toLowerCase(),
        tokens: this.tokenize(query),
        total: 0,
        items: []
      };
    };

    /**
     * Searches through all items and returns a sorted array of matches.
     *
     * The `options` parameter can contain:
     *
     *  -fields {string|array}
     *  -sort {array}
     *  -score {function}
     *  -filter {bool}
     *  -limit {integer}
     *
     * Returns an object containing:
     *
     *  -options {object}
     *  -query {string}
     *  -tokens {array}
     *  -total {int}
     *  -items {array}
     *
     * @param {string} query
     * @param {object} options
     * @returns {object}
     */
    Sifter.prototype.search = function(query, options) {
      var self = this,
        value,
        score,
        search,
        calculateScore,
        fn_sort,
        fn_score;

      search = this.prepareSearch(query, options);
      options = search.options;
      query = search.query;

      // generate result scoring function
      fn_score = options.score || self.getScoreFunction(search);

      // perform search and sort
      if (query.length) {
        self.iterator(self.items, function(item, id) {
          score = fn_score(item);
          if (options.filter === false || score > 0) {
            search.items.push({
              'score': score,
              'id': id
            });
          }
        });
      } else {
        self.iterator(self.items, function(item, id) {
          search.items.push({
            'score': 1,
            'id': id
          });
        });
      }

      fn_sort = self.getSortFunction(search, options);
      if (fn_sort) {
        search.items.sort(fn_sort);
      }

      // apply limits
      search.total = search.items.length;
      if (typeof options.limit === 'number') {
        search.items = search.items.slice(0, options.limit);
      }

      return search;
    };

    return Sifter;
  }));

  /**
   * selectize.js (v0.11.2)
   * Copyright (c) 2013 Brian Reavis & contributors
   *
   * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this
   * file except in compliance with the License. You may obtain a copy of the License at:
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
   * ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   *
   * @author Brian Reavis <brian@thirdroute.com>
   */

  /*jslint vars: true */
  /*jslint browser: true */
  /*jslint nomen: true */

  (function(root, factory) {
    'use strict';
    root.Selectize = factory(root, root.Sifter, root.MicroPlugin);
  }(window.atFormLookup = window.atFormLookup || {}, function(root, Sifter, MicroPlugin) {
    'use strict';

    // ---- start of util functions

    // returs the height of the html elem as clientHeight-padding top and bottom
    function height(htmlElem) {
      var clientHeight = htmlElem.clientHeight;
      var computedStyle = window.getComputedStyle(htmlElem);
      var paddingTop = computedStyle.getPropertyValue('padding-top');
      var paddingBottom = computedStyle.getPropertyValue('padding-bottom');
      paddingTop = !parseInt(paddingTop, 10) ? 0 : parseInt(paddingTop, 10);
      paddingBottom = !parseInt(paddingBottom, 10) ? 0 : parseInt(paddingBottom, 10);

      return clientHeight - paddingTop - paddingBottom;
    }

    // returs the height of the html elem as clientHeight + margin top and bottom
    function completeOuterHeight(htmlElem) {
      var clientHeight = htmlElem.clientHeight;
      var computedStyle = window.getComputedStyle(htmlElem);
      var marginTop = computedStyle.getPropertyValue('margin-top');
      var marginBottom = computedStyle.getPropertyValue('margin-bottom');
      marginTop = !parseInt(marginTop, 10) ? 0 : parseInt(marginTop, 10);
      marginBottom = !parseInt(marginBottom, 10) ? 0 : parseInt(marginBottom, 10);

      return clientHeight + marginTop + marginBottom;
    }

    function isFunction(arg) {
      return Object.prototype.toString.call(arg) === "[object Function]";
    }

    function isPlainObject(arg) {
      return Object.prototype.toString.call(arg) === "[object Object]";
    }

    function isArray(arg) {
      return Object.prototype.toString.call(arg) === "[object Array]";
    }

    function extend() {
      var src, copyIsArray, copy, name, options, clone, target = arguments[0] || {},
        i = 1,
        length = arguments.length,
        deep = false;

      // Handle a deep copy situation
      if (typeof target === "boolean") {
        deep = target;
        target = arguments[1] || {};
        // skip the boolean and the target
        i = 2;
      }

      // Handle case when target is a string or something (possible in deep copy)
      if (typeof target !== "object" && !isFunction(target)) {
        target = {};
      }

      // extend jQuery itself if only one argument is passed
      if (length === i) {
        target = this;
        i -= 1;
      }

      while (i < length) {
        // Only deal with non-null/undefined values
        if ((options = arguments[i]) !== null) {
          // Extend the base object
          for (name in options) {
            if (options.hasOwnProperty(name)) {
              src = target[name];
              copy = options[name];

              // Prevent never-ending loop
              if (target !== copy) {
                // Recurse if we're merging plain objects or arrays
                if (deep && copy && (isPlainObject(copy) || (copyIsArray === isArray(copy)))) {
                  if (copyIsArray) {
                    copyIsArray = false;
                    clone = src && isArray(src) ? src : [];

                  } else {
                    clone = src && isPlainObject(src) ? src : {};
                  }

                  // Never move original objects, clone them
                  target[name] = extend(deep, clone, copy);

                  // Don't bring in undefined values
                } else if (copy !== undefined) {
                  target[name] = copy;
                }
              }
            }
          }
        }
        i += 1;
      }

      // Return the modified object
      return target;
    }


    // ------- end of utils

    var highlight = function($element, pattern) {
      if (typeof pattern === 'string' && !pattern.length) {
        return;
      }
      var regex = (typeof pattern === 'string') ? new RegExp(pattern, 'i') : pattern;

      var highlight = function(node) {
        var i, skip = 0;
        if (node.nodeType === 3) {
          var pos = node.data.search(regex);
          if (pos >= 0 && node.data.length > 0) {
            var match = node.data.match(regex);
            var spannode = document.createElement('span');
            spannode.className = 'highlight';
            var middlebit = node.splitText(pos);
            var endbit = middlebit.splitText(match[0].length);
            var middleclone = middlebit.cloneNode(true);
            spannode.appendChild(middleclone);
            middlebit.parentNode.replaceChild(spannode, middlebit);
            skip = 1;
          }
        } else if (node.nodeType === 1 && node.childNodes && !/(script|style)/i.test(node.tagName)) {
          for (i = 0; i < node.childNodes.length; i += 1) {
            i += highlight(node.childNodes[i]);
          }
        }
        return skip;
      };

      return highlight($element);
    };

    var MicroEvent = function() {};
    MicroEvent.prototype = {
      on: function(event, fct) {
        this._events = this._events || {};
        this._events[event] = this._events[event] || [];
        this._events[event].push(fct);
      },
      off: function(event, fct) {
        var n = arguments.length;
        if (n === 0) {
          return delete this._events;
        }
        if (n === 1) {
          return delete this._events[event];
        }

        this._events = this._events || {};
        if (!this._events.hasOwnProperty(event)) {
          return;
        }
        this._events[event].splice(this._events[event].indexOf(fct), 1);
      },
      trigger: function(event) { /* , args... */
        var i;
        this._events = this._events || {};
        if (!this._events.hasOwnProperty(event)) {
          return;
        }
        for (i = 0; i < this._events[event].length; i += 1) {
          this._events[event][i].apply(this, Array.prototype.slice.call(arguments, 1));
        }
      }
    };

    /**
     * Mixin will delegate all MicroEvent.js function in the destination object.
     *
     *-MicroEvent.mixin(Foobar) will make Foobar able to use MicroEvent
     *
     * @param {object} the object which will support MicroEvent
     */
    MicroEvent.mixin = function(destObject) {
      var props = ['on', 'off', 'trigger'],
        i;
      for (i = 0; i < props.length; i += 1) {
        destObject.prototype[props[i]] = MicroEvent.prototype[props[i]];
      }
    };

    var IS_MAC = /Mac/.test(navigator.userAgent);

    var KEY_A = 65;
    var KEY_COMMA = 188;
    var KEY_RETURN = 13;
    var KEY_ESC = 27;
    var KEY_LEFT = 37;
    var KEY_UP = 38;
    var KEY_P = 80;
    var KEY_RIGHT = 39;
    var KEY_DOWN = 40;
    var KEY_N = 78;
    var KEY_BACKSPACE = 8;
    var KEY_DELETE = 46;
    var KEY_SHIFT = 16;
    var KEY_CMD = IS_MAC ? 91 : 17;
    var KEY_CTRL = IS_MAC ? 18 : 17;
    var KEY_TAB = 9;

    var TAG_SELECT = 1;
    var TAG_INPUT = 2;


    var isset = function(object) {
      return typeof object !== 'undefined';
    };

    /**
     * Converts a scalar to its best string representation
     * for hash keys and HTML attribute values.
     *
     * Transformations:
     *   'str'     -> 'str'
     *   null      -> ''
     *   undefined -> ''
     *   true      -> '1'
     *   false     -> '0'
     *   0         -> '0'
     *   1         -> '1'
     *
     * @param {string} value
     * @returns {string|null}
     */
    var hash_key = function(value) {
      if (typeof value === 'undefined' || value === null) {
        return null;
      }
      if (typeof value === 'boolean') {
        return value ? '1' : '0';
      }
      return String(value);
    };

    /**
     * Escapes a string for use within HTML.
     *
     * @param {string} str
     * @returns {string}
     */
    var escape_html = function(str) {
      return String(str)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;');
    };

    /**
     * Escapes "$" characters in replacement strings.
     *
     * @param {string} str
     * @returns {string}
     */
    var escape_replace = function(str) {
      return String(str).replace(/\$/g, '$$$$');
    };

    var hook = {};

    /**
     * Wraps `method` on `self` so that `fn`
     * is invoked before the original method.
     *
     * @param {object} self
     * @param {string} method
     * @param {function} fn
     */
    hook.before = function(self, method, fn) {
      var original = self[method];
      self[method] = function() {
        fn.apply(self, arguments);
        return original.apply(self, arguments);
      };
    };

    /**
     * Wraps `method` on `self` so that `fn`
     * is invoked after the original method.
     *
     * @param {object} self
     * @param {string} method
     * @param {function} fn
     */
    hook.after = function(self, method, fn) {
      var original = self[method];
      self[method] = function() {
        var result = original.apply(self, arguments);
        fn.apply(self, arguments);
        return result;
      };
    };

    /**
     * Builds a hash table out of an array of
     * objects, using the specified `key` within
     * each object.
     *
     * @param {string} key
     * @param {mixed} objects
     */
    var build_hash_table = function(key, objects) {
      if (!isArray(objects)) {
        return objects;
      }
      var i, n, table = {};
      for (i = 0, n = objects.length; i < n; i += 1) {
        if (objects[i].hasOwnProperty(key)) {
          table[objects[i][key]] = objects[i];
        }
      }
      return table;
    };

    /**
     * Wraps `fn` so that it can only be invoked once.
     *
     * @param {function} fn
     * @returns {function}
     */
    var once = function(fn) {
      var called = false;
      return function() {
        if (called) {
          return;
        }
        called = true;
        fn.apply(this, arguments);
      };
    };

    /**
     * Wraps `fn` so that it can only be called once
     * every `delay` milliseconds (invoked on the falling edge).
     *
     * @param {function} fn
     * @param {int} delay
     * @returns {function}
     */
    var debounce = function(fn, delay) {
      var timeout;
      return function() {
        var self = this;
        var args = arguments;
        window.clearTimeout(timeout);
        timeout = window.setTimeout(function() {
          fn.apply(self, args);
        }, delay);
      };
    };

    /**
     * Debounce all fired events types listed in `types`
     * while executing the provided `fn`.
     *
     * @param {object} self
     * @param {array} types
     * @param {function} fn
     */
    var debounce_events = function(self, types, fn) {
      var type;
      var trigger = self.trigger;
      var event_args = {};

      // override trigger method
      self.trigger = function() {
        var type = arguments[0];
        if (types.indexOf(type) !== -1) {
          event_args[type] = arguments;
        } else {
          return trigger.apply(self, arguments);
        }
      };

      // invoke provided function
      fn.apply(self, []);
      self.trigger = trigger;

      // trigger queued events
      for (type in event_args) {
        if (event_args.hasOwnProperty(type)) {
          trigger.apply(self, event_args[type]);
        }
      }
    };

    /**
     * A workaround for http://bugs.jquery.com/ticket/6696
     *
     * @param {object} $parent-Parent element to listen on.
     * @param {string} event-Event name.
     * @param {string} selector-Descendant selector to filter by.
     * @param {function} fn-Event handler.
     */
    var watchChildEvent = function($parent, event, selector, fn) {
      var children = $parent.querySelectorAll(selector),
        i;
      for (i = 0; i < children.length; i += 1) {
        var child = children[i];
        child.addEventListener(event, function(e) {
          var child = e.target;
          while (child && child.parentNode !== $parent[0]) {
            child = child.parentNode;
          }
          e.currentTarget = child;
          return fn.apply(this, [e]);
        });
      }
    };

    /**
     * Determines the current selection within a text input control.
     * Returns an object containing:
     *  -start
     *  -length
     *
     * @param {object} input
     * @returns {object}
     */
    var getSelection = function(input) {
      var result = {
        start: 0,
        length: 0
      };
      if (input.hasOwnProperty('selectionStart')) {
        result.start = input.selectionStart;
        result.length = input.selectionEnd - result.start;
      } else if (document.selection) {
        input.focus();
        var sel = document.selection.createRange();
        var selLen = document.selection.createRange().text.length;
        sel.moveStart('character', -input.value.length);
        result.start = sel.text.length - selLen;
        result.length = selLen;
      }
      return result;
    };

    /**
     * Copies CSS properties from one element to another.
     *
     * @param {object} $from
     * @param {object} $to
     * @param {array} properties
     */
    var transferStyles = function($from, $to, properties) {
      var i, n;
      if (properties) {
        for (i = 0, n = properties.length; i < n; i += 1) {
          $to[properties[i]] = $from.style[properties[i]];
        }
      }
    };

    /**
     * Measures the width of a string within a
     * parent element (in pixels).
     *
     * @param {string} str
     * @param {object} $parent
     * @returns {int}
     */
    var measureString = function(str, $parent) {
      if (!str) {
        return 0;
      }

      var body = document.getElementsByTagName('body');
      body = body[0];
      var test = document.createElement('test');
      body.appendChild(test);
      test.innerText = str;

      test.style.position = 'absolute';
      test.style.top = -99999;
      test.style.left = -99999;
      test.style.width = 'auto';
      test.style.padding = 0;
      test.style.whiteSpace = 'pre';

      transferStyles($parent, test, [
        'letterSpacing',
        'fontSize',
        'fontFamily',
        'fontWeight',
        'textTransform'
      ]);

      var width = test.clientWidth;
      test.parentElement.removeChild(test);

      return width;
    };

    /**
     * Sets up an input to grow horizontally as the user
     * types. If the value is changed manually, you can
     * trigger the "update" handler to resize:
     *
     * $input.trigger('update');
     *
     * @param {object} $input
     */
    var autoGrow = function($input) {
      var currentWidth = null;

      var update = function(e, options) {
        var value, keyCode, printable, placeholder, width;
        var shift, character, selection;
        e = e || window.event || {};
        options = options || {};

        if (e.metaKey || e.altKey) {
          return;
        }
        if (!options.force && $input.attributes.getNamedItem('data-grow') && $input.attributes.getNamedItem('data-grow').value === false) {
          return;
        }

        value = $input.value;
        if (e.type && e.type.toLowerCase() === 'keydown') {
          keyCode = e.keyCode;
          printable = (
            (keyCode >= 97 && keyCode <= 122) || // a-z
            (keyCode >= 65 && keyCode <= 90) || // A-Z
            (keyCode >= 48 && keyCode <= 57) || // 0-9
            keyCode === 32 // space
          );

          if (keyCode === KEY_DELETE || keyCode === KEY_BACKSPACE) {
            selection = getSelection($input);
            if (selection.length) {
              value = value.substring(0, selection.start) + value.substring(selection.start + selection.length);
            } else if (keyCode === KEY_BACKSPACE && selection.start) {
              value = value.substring(0, selection.start - 1) + value.substring(selection.start + 1);
            } else if (keyCode === KEY_DELETE && typeof selection.start !== 'undefined') {
              value = value.substring(0, selection.start) + value.substring(selection.start + 1);
            }
          } else if (printable) {
            shift = e.shiftKey;
            character = String.fromCharCode(e.keyCode);
            if (shift) {
              character = character.toUpperCase();
            } else {
              character = character.toLowerCase();
            }
            value += character;
          }
        }

        placeholder = $input.attributes.getNamedItem('placeholder') && $input.attributes.getNamedItem('placeholder').value;
        if (!value && placeholder) {
          value = placeholder;
        }

        width = measureString(value, $input) + 4;
        if (width !== currentWidth) {
          currentWidth = width;
          $input.style.width = width + 'px';
          var resizeEvent = document.createEvent('Event');
          resizeEvent.initEvent('resize', true, true);
          $input.dispatchEvent(resizeEvent);
        }
      };

      $input.addEventListener('keydown', update);
      $input.addEventListener('keyup', update);
      $input.addEventListener('update', update);
      $input.addEventListener('blur', update);
      update();
    };

    function getTextDirectionFromParents(startElement) {
      var parentElement = startElement.parentElement || startElement.parentNode;
      var textDirectionValue = parentElement && parentElement.getAttribute ? parentElement.getAttribute('dir') : 'ltrw';
      if (textDirectionValue !== undefined && textDirectionValue !== null && textDirectionValue !== '') {
        return textDirectionValue;
      } else {
        return getTextDirectionFromParents(parentElement);
      }
    }

    var Selectize = function($input, settings) {
      var key, i, n, dir, input, self = this;
      input = $input;
      input.selectize = self;

      // detect rtl environment
      var computedStyle = window.getComputedStyle && window.getComputedStyle(input, null);
      dir = computedStyle ? computedStyle.getPropertyValue('direction') : input.currentStyle && input.currentStyle.direction;
      //dir = dir || $input.parents('[dir]:first').attr('dir') || '';
      dir = dir || getTextDirectionFromParents($input) || '';

      // setup default state
      extend(self, {
        settings: settings,
        $input: $input,
        tagType: input.tagName.toLowerCase() === 'select' ? TAG_SELECT : TAG_INPUT,
        rtl: /rtl/i.test(dir),

        eventNS: '.selectize' + (Selectize.count + 1),
        highlightedValue: null,
        isOpen: false,
        isDisabled: false,
        isRequired: $input.attributes.getNamedItem('required'),
        isInvalid: false,
        isLocked: false,
        isFocused: false,
        isInputHidden: false,
        isSetup: false,
        isInitializing: false,
        isShiftDown: false,
        isCmdDown: false,
        isCtrlDown: false,
        ignoreFocus: false,
        ignoreBlur: false,
        ignoreHover: false,
        hasOptions: false,
        currentResults: null,
        lastValue: '',
        caretPos: 0,
        loading: 0,
        loadedSearches: {},

        $activeOption: null,
        $activeItems: [],

        optgroups: {},
        options: {},
        userOptions: {},
        items: [],
        renderCache: {},
        onSearchChange: settings.loadThrottle === null ? self.onSearchChange : debounce(self.onSearchChange, settings.loadThrottle)
      });

      // search system
      self.sifter = new Sifter(this.options, {
        diacritics: settings.diacritics
      });

      // build options table
      extend(self.options, build_hash_table(settings.valueField, settings.options));
      delete self.settings.options;

      // build optgroup table
      extend(self.optgroups, build_hash_table(settings.optgroupValueField, settings.optgroups));
      delete self.settings.optgroups;

      // option-dependent defaults
      self.settings.mode = self.settings.mode || (self.settings.maxItems === 1 ? 'single' : 'multi');
      if (typeof self.settings.hideSelected !== 'boolean') {
        self.settings.hideSelected = self.settings.mode === 'multi';
      }

      self.initializePlugins(self.settings.plugins);
      self.setupCallbacks();
      self.setupTemplates();
      self.setup();
    };

    // mixins
    //-------------------------------------------- -

    MicroEvent.mixin(Selectize);
    MicroPlugin.mixin(Selectize);


    // methods
    //-------------------------------------------- -
    (function(namespace) {

      /**
       * Creates all elements and sets up event bindings.
       */
      namespace.setup = function() {
        var self = this;
        var settings = self.settings;
        var eventNS = self.eventNS;
        var $window = window;
        var $document = document;
        var $input = self.$input;

        var $wrapper;
        var $control;
        var $control_input;
        var $dropdown;
        var $dropdown_content;
        var $dropdown_parent;
        var inputMode;
        var timeout_blur;
        var timeout_focus;
        var tab_index;
        var classes;
        var classes_plugins;
        var i, tabIndexAttr;

        inputMode = self.settings.mode;
        tab_index = $input.getAttribute('tabindex') !== null ? $input.getAttribute('tabindex') : 1;
        classes = $input.getAttribute('class') !== null ? $input.getAttribute('class') : '';
        classes = classes.split(' ');

        $wrapper = document.createElement('div');
        $wrapper.classList.add(settings.wrapperClass);
        for (i = 0; i < classes.length; i += 1) {
          if (classes[i] !== "") {
            $wrapper.classList.add(classes[i]);
          }
        }
        $wrapper.classList.add(inputMode);

        $control = document.createElement('div');
        $control.classList.add(settings.inputClass);
        $control.classList.add('items');
        //      $wrapper.appendChild($control);
        Polymer.dom($wrapper).appendChild($control);

        $control_input = document.createElement('input');
        $control_input.setAttribute('type', 'text');
        $control_input.setAttribute('autocomplete', 'off');
        // $control_input.setAttribute('tabindex', tab_index);

        Polymer.dom($control).appendChild($control_input);

        $dropdown_parent = settings.dropdownParent || $wrapper;

        $dropdown = document.createElement('div');
        $dropdown.classList.add(settings.dropdownClass);
        $dropdown.classList.add(inputMode);
        $dropdown.style.display = "none";
        Polymer.dom($dropdown_parent).appendChild($dropdown);

        var paperShadow = document.createElement('paper-shadow');
        paperShadow.z = 2;
        Polymer.dom($dropdown).appendChild(paperShadow);

        $dropdown_content = document.createElement('div');
        $dropdown_content.classList.add(settings.dropdownContentClass);
        Polymer.dom($dropdown).appendChild($dropdown_content);

        $dropdown_content.addEventListener('mousedown', function(e) {
          e.preventDefault();
          if (e.target !== self.$dropdown_content) {
            if (e.target.parentElement === self.$dropdown_content) {
              self.setActiveOption(e.target, true, true);
              self.onOptionSelect({
                currentTarget: self.$activeOption
              });
            } else {
              self.setActiveOption(e.target.parentElement, true, true);
              self.onOptionSelect({
                currentTarget: self.$activeOption
              });
            }
          }
        });

        if (self.settings.copyClassesToDropdown) {
          for (i = 0; i < classes.length; i += 1) {
            if (classes[i] !== "") {
              $dropdown.classList.add(classes[i]);
            }
          }
        }

        $wrapper.style.width = $input.style.width;

        if (self.plugins.names.length) {
          classes_plugins = 'plugin-' + self.plugins.names.join(' plugin-');
          $wrapper.classList.add(classes_plugins);
          $dropdown.classList.add(classes_plugins);
        }

        if ((settings.maxItems === null || settings.maxItems > 1)) { //&& self.tagType === TAG_SELECT
          $input.setAttribute('multiple', 'multiple');
        }

        if (self.settings.placeholder) {
          $control_input.setAttribute('placeholder', settings.placeholder);
        }

        if ($input.attributes.getNamedItem('autocorrect')) {
          $control_input.setAttribute('autocorrect', $input.getAttribute('autocorrect'));
        }

        if ($control_input.attributes.getNamedItem('autocapitalize')) {
          $control_input.setAttribute('autocapitalize', $input.getAttribute('autocapitalize'));
        }

        self.$wrapper = $wrapper;
        self.$control = $control;
        self.$control_input = $control_input;
        self.$dropdown = $dropdown;
        self.$dropdown_content = $dropdown_content;
        watchChildEvent($control, 'mousedown', '*:not(input)', function() {
          return self.onItemSelect.apply(self, arguments);
        });
        autoGrow($control_input);

        $control.addEventListener('mousedown', function() {
          return self.onMouseDown.apply(self, arguments);
        });
        $control.addEventListener('touchstart', function() {
          return self.onMouseDown.apply(self, arguments);
        });
        $control.addEventListener('click', function() {
          return self.onClick.apply(self, arguments);
        });

        $control.addEventListener('touchstart', function(e) {
          e.stopPropagation();
        });
        $control_input.addEventListener('mousedown', function(e) {
          e.stopPropagation();
        });
        $control_input.addEventListener('keydown', function() {
          return self.onKeyDown.apply(self, arguments);
        });
        $control_input.addEventListener('keyup', function() {
          return self.onKeyUp.apply(self, arguments);
        });
        $control_input.addEventListener('keypress', function() {
          return self.onKeyPress.apply(self, arguments);
        });
        $control_input.addEventListener('resize', function() {
          self.positionDropdown.apply(self, []);
        });
        $control_input.addEventListener('blur', function() {
          return self.onBlur.apply(self, arguments);
        });
        $control_input.addEventListener('focus', function() {
          self.ignoreBlur = false;
          return self.onFocus.apply(self, arguments);
        });
        $control_input.addEventListener('paste', function() {
          return self.onPaste.apply(self, arguments);
        });

        $document.addEventListener('keydown' + eventNS, function(e) {
          self.isCmdDown = e[IS_MAC ? 'metaKey' : 'ctrlKey'];
          self.isCtrlDown = e[IS_MAC ? 'altKey' : 'ctrlKey'];
          self.isShiftDown = e.shiftKey;
        });

        $document.addEventListener('keyup' + eventNS, function(e) {
          if (e.keyCode === KEY_CTRL) {
            self.isCtrlDown = false;
          }
          if (e.keyCode === KEY_SHIFT) {
            self.isShiftDown = false;
          }
          if (e.keyCode === KEY_CMD) {
            self.isCmdDown = false;
          }
        });

        $document.addEventListener('mousedown' + eventNS, function(e) {
          if (self.isFocused) {
            // prevent events on the dropdown scrollbar from causing the control to blur
            if (e.target === self.$dropdown || e.target.parentNode === self.$dropdown) {
              return false;
            }
            // blur on click outside
            if (!self.$control.has(e.target).length && e.target !== self.$control) {
              self.blur();
            }
          }
        });

        $window.addEventListener(['scroll' + eventNS, 'resize' + eventNS].join(' '), function() {
          if (self.isOpen) {
            self.positionDropdown.apply(self, arguments);
          }
        });
        $window.addEventListener('mousemove' + eventNS, function() {
          self.ignoreHover = false;
        });

        // store original children and tab index so that they can be
        // restored when the destroy() method is called.
        var childElements = [];
        for (i = 0; i < Polymer.dom($input).childNodes.length; i += 1) {
          var child = Polymer.dom($input).childNodes[i];
          Polymer.dom($input).removeChild(child);
          childElements.push(child);
        }
        tabIndexAttr = $input.getAttribute('tabindex');
        this.revertSettings = {
          $children: childElements,
          tabindex: tabIndexAttr ? tabIndexAttr : '1'
        };

        // $input.setAttribute('tabindex', 1);
        $input.style.display = 'none';
        Polymer.dom($input.parentNode).insertBefore(self.$wrapper, $input.nextSibling);
        //self.$wrapper.appendChild($input);

        if (isArray(settings.items)) {
          self.setValue(settings.items);
          delete settings.items;
        }

        // feature detect for the validation API
        if ($input.validity) {
          $input.addEventListener('invalid' + eventNS, function(e) {
            e.preventDefault();
            self.isInvalid = true;
            self.refreshState();
          });
        }

        self.updateOriginalInput();
        self.refreshItems();
        self.refreshState();
        self.updatePlaceholder();
        self.isSetup = true;

        if ($input.getAttribute('disabled') !== undefined && $input.getAttribute('disabled') !== null) {
          self.disable();
        }

        self.on('change', this.onChange);

        root.data($input, 'selectize', self);

        $input.classList.add('selectized');
        self.trigger('initialize');

        // preload options
        if (settings.preload === true || settings.preload === "true") {
          self.onSearchChange('');
        }
      };

      /**
       * Sets up default rendering functions.
       */
      namespace.setupTemplates = function() {
        var self = this;
        var field_label = self.settings.labelField;
        var field_optgroup = self.settings.optgroupLabelField;

        var templates = {
          'optgroup': function(data) {
            return '<div class="optgroup">' + data.html + '</div>';
          },
          'optgroup_header': function(data, escape) {
            return '<div class="optgroup-header">' + escape(data[field_optgroup]) + '</div>';
          },
          'option': function(data, escape) {
            return '<div class="option">' + escape(data[field_label]) + '</div>';
          },
          'item': function(data, escape) {
            return '<div class="item">' + escape(data[field_label]) + '</div>';
          },
          'option_create': function(data, escape) {
            return '<div class="create">Add <strong>' + escape(data.input) + '</strong>&hellip;</div>';
          }
        };

        self.settings.render = extend({}, templates, self.settings.render);
      };

      /**
       * Maps fired events to callbacks provided
       * in the settings used when creating the control.
       */
      namespace.setupCallbacks = function() {
        var key, fn, callbacks = {
          'initialize': 'onInitialize',
          'change': 'onChange',
          'item_add': 'onItemAdd',
          'item_remove': 'onItemRemove',
          'clear': 'onClear',
          'option_add': 'onOptionAdd',
          'option_remove': 'onOptionRemove',
          'option_clear': 'onOptionClear',
          'dropdown_open': 'onDropdownOpen',
          'dropdown_close': 'onDropdownClose',
          'type': 'onType',
          'load': 'onLoad'
        };

        for (key in callbacks) {
          if (callbacks.hasOwnProperty(key)) {
            fn = this.settings[callbacks[key]];
            if (fn) {
              this.on(key, fn);
            }
          }
        }
      };

      /**
       * Triggered when the main control element
       * has a click event.
       *
       * @param {object} e
       * @return {boolean}
       */
      namespace.onClick = function(e) {
        var self = this;

        // necessary for mobile webkit devices (manual focus triggering
        // is ignored unless invoked within a click event)
        if (!self.isFocused) {
          self.focus();
          e.preventDefault();
        }
      };

      /**
       * Triggered when the main control element
       * has a mouse down event.
       *
       * @param {object} e
       * @return {boolean}
       */
      namespace.onMouseDown = function(e) {
        var self = this;
        var defaultPrevented = e.defaultPrevented;
        var $target = e.target;

        if (self.isFocused) {
          // retain focus by preventing native handling. if the
          // event target is the input it should not be modified.
          // otherwise, text selection within the input won't work.
          if (e.target !== self.$control_input) {
            if (self.settings.mode === 'single') {
              // toggle dropdown
              if (self.isOpen) {
                self.close();
              } else {
                self.open();
              }
            } else if (!defaultPrevented) {
              self.setActiveItem(null);
            }
            return false;
          }
        } else {
          // give control focus
          if (!defaultPrevented) {
            window.setTimeout(function() {
              self.focus();
            }, 0);
          }
        }
      };

      /**
       * Triggered when the value of the control has been changed.
       * This should propagate the event to the original DOM
       * input / select element.
       */
      namespace.onChange = function() {
        var changeEvent = document.createEvent('HTMLEvents');
        changeEvent.initEvent('change', false, false);
        this.$input.dispatchEvent(changeEvent);

        //        this.$input.trigger('change');
      };

      /**
       * Triggered on <input> paste.
       *
       * @param {object} e
       * @returns {boolean}
       */
      namespace.onPaste = function(e) {
        var self = this;
        if (self.isFull() || self.isInputHidden || self.isLocked) {
          e.preventDefault();
        }
      };

      /**
       * Triggered on <input> keypress.
       *
       * @param {object} e
       * @returns {boolean}
       */
      namespace.onKeyPress = function(e) {
        if (this.isLocked) {
          return e && e.preventDefault();
        }
        var character = String.fromCharCode(e.keyCode || e.which);
        if (this.settings.create && character === this.settings.delimiter) {
          this.createItem();
          e.preventDefault();
          return false;
        }
      };

      /**
       * Triggered on <input> keydown.
       *
       * @param {object} e
       * @returns {boolean}
       */
      namespace.onKeyDown = function(e) {
        var isInput = e.target === this.$control_input;
        var self = this;

        if (self.isLocked) {
          if (e.keyCode !== KEY_TAB) {
            e.preventDefault();
          }
          return;
        }

        switch (e.keyCode) {
          case KEY_A:
            if (self.isCmdDown) {
              self.selectAll();
              return;
            }
            break;
          case KEY_ESC:
            self.close();
            return;
          case KEY_DOWN:
            if (e.keyCode === KEY_N && ((!e.ctrlKey || e.altKey))) {
              break;
            }
            if (!self.isOpen && self.hasOptions) {
              self.open();
            } else if (self.$activeOption) {
              self.ignoreHover = true;
              var $next = self.getAdjacentOption(self.$activeOption, 1);
              if ($next.length) {
                self.setActiveOption($next[0], true, true);
              }
            } else {
              var $first = self.getFirstItem();
              if ($first !== undefined) {
                self.setActiveOption($first, true, true);
              }
            }
            e.preventDefault();
            return;
          case KEY_UP:
            if (e.keyCode === KEY_P && (!e.ctrlKey || e.altKey)) {
              break;
            }
            if (self.$activeOption) {
              self.ignoreHover = true;
              var $prev = self.getAdjacentOption(self.$activeOption, -1);
              if ($prev.length) {
                self.setActiveOption($prev[0], true, true);
              }
            }
            e.preventDefault();
            return;
          case KEY_RETURN:
            if (self.isOpen && self.$activeOption) {
              self.onOptionSelect({
                currentTarget: self.$activeOption
              });
            }
            if (self.settings.maxItems === 1) {
              var blurEvent = document.createEvent('Event');
              blurEvent.initEvent('blur', true, true);
              self.$control_input.dispatchEvent(blurEvent);
            }
            e.preventDefault();
            return;
          case KEY_LEFT:
            self.advanceSelection(-1, e);
            return;
          case KEY_RIGHT:
            self.advanceSelection(1, e);
            return;
          case KEY_TAB:
            if (!self.$activeOption) {
              self.$activeOption = self.getFirstItem();
            }
            if (self.settings.selectOnTab && self.isOpen && self.$activeOption) {
              self.onOptionSelect({
                currentTarget: self.$activeOption
              });
              // e.preventDefault();
            }
            if (self.settings.create && self.createItem()) {
              // e.preventDefault();
            }
            // if (self.isOpen) {
            var blurEvent = document.createEvent('Event');
            blurEvent.initEvent('blur', true, true);
            self.$control_input.dispatchEvent(blurEvent);
            // }
            return;
          case KEY_BACKSPACE:
          case KEY_DELETE:
            self.deleteSelection(e);
            return;
        }

        if ((self.isFull() || self.isInputHidden) && !(IS_MAC ? e.metaKey : e.ctrlKey)) {
          e.preventDefault();
          return;
        }
      };

      /**
       * Triggered on <input> keyup.
       *
       * @param {object} e
       * @returns {boolean}
       */
      namespace.onKeyUp = function(e) {
        var self = this;

        if (self.isLocked) {
          return e && e.preventDefault();
        }
        var value = self.$control_input.value || '';
        if (self.lastValue !== value) {
          self.lastValue = value;
          self.onSearchChange(value);
          self.refreshOptions();
          self.trigger('type', value);
        }
      };

      /**
       * Invokes the user-provide option provider / loader.
       *
       * Note: this function is debounced in the Selectize
       * constructor (by `settings.loadDelay` milliseconds)
       *
       * @param {string} value
       */
      namespace.onSearchChange = function(value) {
        var self = this;
        var fn = self.settings.load;
        if (!fn) {
          return;
        }
        if (self.loadedSearches.hasOwnProperty(value)) {
          return;
        }
        self.loadedSearches[value] = true;
        self.load(function(callback) {
          fn.apply(self, [value, callback]);
        });
      };

      /**
       * Triggered on <input> focus.
       *
       * @param {object} e (optional)
       * @returns {boolean}
       */
      namespace.onFocus = function(e) {
        var self = this;

        self.isFocused = true;
        if (self.isDisabled) {
          self.blur();
          if (e) {
            e.preventDefault();
          }
          return false;
        }

        if (self.ignoreFocus) {
          return;
        }
        if (self.settings.preload === 'focus') {
          self.onSearchChange('');
        }

        if (!self.$activeItems.length) {
          self.showInput();
          self.setActiveItem(null);
          self.refreshOptions(!!self.settings.openOnFocus);
        }

        self.refreshState();
        self.$control_input.focus();
      };

      /**
       * Triggered on <input> blur.
       *
       * @param {object} e
       * @returns {boolean}
       */
      namespace.onBlur = function(e) {
        var self = this;
        self.isFocused = false;
        if (self.ignoreFocus) {
          return;
        }

        // necessary to prevent IE closing the dropdown when the scrollbar is clicked
        if (!self.ignoreBlur && document.activeElement === self.$dropdown_content) {
          self.ignoreBlur = true;
          self.onFocus(e);

          return;
        }

        if (self.settings.create && self.settings.createOnBlur) {
          self.createItem(false);
        }

        self.close();
        self.setTextboxValue('');
        self.setActiveItem(null);
        self.setActiveOption(null);
        self.setCaret(self.items.length);
        self.refreshState();
      };

      /**
       * Triggered when the user rolls over
       * an option in the autocomplete dropdown menu.
       *
       * @param {object} e
       * @returns {boolean}
       */
      namespace.onOptionHover = function(e) {
        if (this.ignoreHover) {
          return;
        }
        this.setActiveOption(e.currentTarget, false);
      };

      /**
       * Triggered when the user clicks on an option
       * in the autocomplete dropdown menu.
       *
       * @param {object} e
       * @returns {boolean}
       */
      namespace.onOptionSelect = function(e) {
        var value, $target, $option, self = this;

        if (e.preventDefault) {
          e.preventDefault();
          e.stopPropagation();
        }

        $target = e.currentTarget;
        if ($target.classList.contains('create')) {
          self.createItem();
        } else {
          value = $target.getAttribute('data-value');
          if (typeof value !== 'undefined') {
            self.lastQuery = null;
            self.setTextboxValue('');
            self.addItem(value);
            if (!self.settings.hideSelected && e.type && /mouse/.test(e.type)) {
              self.setActiveOption(self.getOption(value));
            }
          }
        }
      };

      /**
       * Triggered when the user clicks on an item
       * that has been selected.
       *
       * @param {object} e
       * @returns {boolean}
       */
      namespace.onItemSelect = function(e) {
        var self = this;

        if (self.isLocked) {
          return;
        }
        if (self.settings.mode === 'multi') {
          e.preventDefault();
          self.setActiveItem(e.currentTarget, e);
        }
      };

      /**
       * Invokes the provided method that provides
       * results to a callback---which are then added
       * as options to the control.
       *
       * @param {function} fn
       */
      namespace.load = function(fn) {
        var self = this;
        var polyElem = this.settings.polymerElement;

        fn.apply(self, [function(results) {
          self.loading = Math.max(self.loading - 1, 0);
          if (results && results.length) {
            self.addOption(results);
            self.refreshOptions(self.isFocused && !self.isInputHidden);
          }
          if (!self.loading) {
            self.$wrapper.classList.remove('loading');
          }
          self.trigger('load', results);
        }]);
      };

      /**
       * Sets the input field of the control to the specified value.
       *
       * @param {string} value
       */
      namespace.setTextboxValue = function(value) {
        var $input = this.$control_input;
        var changed = $input.value !== value;
        if (changed) {
          $input.value = value;
          var updateEvent = document.createEvent('Event');
          updateEvent.initEvent('update', false, true);
          $input.dispatchEvent(updateEvent);
          //$input.triggerHandler('update');
          this.lastValue = value;
        }
      };

      /**
       * Returns the value of the control. If multiple items
       * can be selected (e.g. <select multiple>), this returns
       * an array. If only one item can be selected, this
       * returns a string.
       *
       * @returns {mixed}
       */
      namespace.getValue = function() {
        var result = '';
        if (this.tagType === TAG_SELECT && this.$input.getAttribute('multiple')) {
          result = this.items;
        } else {
          result = this.items.join(this.settings.delimiter);
        }

        return result;
      };

      /**
       * Resets the selected items to the given value.
       *
       * @param {mixed} value
       */
      namespace.setValue = function(value) {
        debounce_events(this, ['change'], function() {
          this.clear();
          this.addItems(value);
        });
      };

      /**
       * Sets the selected item.
       *
       * @param {object} $item
       * @param {object} e (optional)
       */
      namespace.setActiveItem = function($item, e) {
        var self = this;
        var eventName;
        var i, idx, begin, end, item, swap;
        var $last;
        var aiIndex;

        if (self.settings.mode === 'single') {
          return;
        }
        //$item = $($item);

        // clear the active selection
        //if (!$item.length) {
        if (!$item) {
          for (aiIndex = 0; i < self.$activeItems.length; aiIndex += 1) {
            self.$activeItems[aiIndex].classList.remove('active');
          }
          self.$activeItems = [];
          if (self.isFocused) {
            self.showInput();
          }
          return;
        }

        // modify selection
        eventName = e && e.type.toLowerCase();

        if (eventName === 'mousedown' && self.isShiftDown && self.$activeItems.length) {
          $last = self.$control.children('.active:last');
          begin = Array.prototype.indexOf.apply(self.$control[0].childNodes, [$last[0]]);
          end = Array.prototype.indexOf.apply(self.$control[0].childNodes, [$item[0]]);
          if (begin > end) {
            swap = begin;
            begin = end;
            end = swap;
          }
          for (i = begin; i <= end; i += 1) {
            item = self.$control.childNodes[i];
            if (self.$activeItems.indexOf(item) === -1) {
              item.classList.add('active');
              self.$activeItems.push(item);
            }
          }
          e.preventDefault();
        } else if ((eventName === 'mousedown' && self.isCtrlDown) || (eventName === 'keydown' && this.isShiftDown)) {
          if ($item.hasClass('active')) {
            idx = self.$activeItems.indexOf($item[0]);
            self.$activeItems.splice(idx, 1);
            $item.removeClass('active');
          } else {
            self.$activeItems.push($item.addClass('active')[0]);
          }
        } else {
          for (aiIndex = 0; aiIndex < self.$activeItems.length; aiIndex += 1) {
            self.$activeItems[aiIndex].classList.remove('active');
          }
          $item.classList.add('active');
          self.$activeItems = [$item];
        }

        // ensure control has focus
        self.hideInput();
        if (!this.isFocused) {
          self.focus();
        }
      };

      /**
       * Sets the selected item in the dropdown menu
       * of available options.
       *
       * @param {object} $object
       * @param {boolean} scroll
       * @param {boolean} animate
       */
      namespace.setActiveOption = function($option, scroll, animate) {
        var height_menu, height_item, y;
        var scroll_top, scroll_bottom;
        var self = this;

        if (self.$activeOption) {
          self.$activeOption.classList.remove('active');
        }
        self.$activeOption = null;

        //$option = $($option);
        if (!$option || (isArray($option) && $option.length === 0)) {
          return;
        }

        if (isArray($option)) {
          $option = $option[0];
        }
        $option.classList.add('active');

        self.$activeOption = $option;

        if (scroll || !isset(scroll)) {
          height_menu = height(self.$dropdown_content);
          height_item = completeOuterHeight(self.$activeOption);
          scroll = self.$dropdown_content.scrollTop || 0;
          if (scroll < 10) {
            scroll = 0;
          }
          var activeOptionTop = self.$activeOption.getBoundingClientRect().top;
          var dropDownContentTop = self.$dropdown_content.getBoundingClientRect().top;
          y = activeOptionTop - dropDownContentTop + scroll;
          scroll_top = y;
          scroll_bottom = y - height_menu + height_item;

          if (y + height_item > height_menu + scroll) {
            self.$dropdown_content.scrollTop = scroll_bottom;
          } else if (y < scroll) {
            self.$dropdown_content.scrollTop = scroll_top;
          }

          if (self.getFirstItem() === self.$activeOption) {
            self.$dropdown_content.scrollTop = 0;
          }
        }
      };

      /**
       * Selects all items (CTRL + A).
       */
      namespace.selectAll = function() {
        var self = this;
        if (self.settings.mode === 'single') {
          return;
        }
        self.$activeItems = Array.prototype.slice.apply(self.$control.children(':not(input)').addClass('active'));
        if (self.$activeItems.length) {
          self.hideInput();
          self.close();
        }
        self.focus();
      };

      /**
       * Hides the input element out of view, while
       * retaining its focus.
       */
      namespace.hideInput = function() {
        var self = this;

        self.setTextboxValue('');
        self.$control_input.style.opacity = 0;
        //        self.$control_input.style.position = 'absolute';
        self.$control_input.style.left = self.rtl ? 10000 : -10000;
        //self.$control_input.css({ opacity: 0, position: 'absolute', left: self.rtl ? 10000 : -10000 });
        self.isInputHidden = true;
      };

      /**
       * Restores input visibility.
       */
      namespace.showInput = function() {
        this.$control_input.style.opacity = 1;
        this.$control_input.style.position = 'relative';
        this.$control_input.style.left = 0;
        this.isInputHidden = false;
      };

      /**
       * Gives the control focus. If "trigger" is falsy,
       * focus handlers won't be fired--causing the focus
       * to happen silently in the background.
       *
       * @param {boolean} trigger
       */
      namespace.focus = function(isProgrammaticFocus) {
        var self = this;
        if (self.isDisabled) {
          return;
        }

        self.ignoreFocus = true;
        var focusEvent = document.createEvent('Event');
        focusEvent.initEvent('focus', true, true);
        self.$control_input.dispatchEvent(focusEvent);
        window.setTimeout(function() {
          self.ignoreFocus = false;
          self.isProgrammaticFocus = !!isProgrammaticFocus;
          self.onFocus();
          self.isProgrammaticFocus = false;
        }, 100);
      };

      /**
       * Forces the control out of focus.
       */
      namespace.blur = function() {
        var blurEvent = document.createEvent('Event');
        blurEvent.initEvent('blur', true, true);
        this.$control_input.dispatchEvent(blurEvent);
      };

      /**
       * Returns a function that scores an object
       * to show how good of a match it is to the
       * provided query.
       *
       * @param {string} query
       * @param {object} options
       * @return {function}
       */
      namespace.getScoreFunction = function(query) {
        return this.sifter.getScoreFunction(query, this.getSearchOptions());
      };

      /**
       * Returns search options for sifter (the system
       * for scoring and sorting results).
       *
       * @see https://github.com/brianreavis/sifter.js
       * @return {object}
       */
      namespace.getSearchOptions = function() {
        var settings = this.settings;
        var sort = settings.sortField;
        if (typeof sort === 'string') {
          sort = {
            field: sort
          };
        }

        return {
          fields: settings.searchField,
          conjunction: settings.searchConjunction,
          sort: sort
        };
      };

      /**
       * Searches through available options and returns
       * a sorted array of matches.
       *
       * Returns an object containing:
       *
       *  -query {string}
       *  -tokens {array}
       *  -total {int}
       *  -items {array}
       *
       * @param {string} query
       * @returns {object}
       */
      namespace.search = function(query) {
        var i, value, score, result, calculateScore;
        var self = this;
        var settings = self.settings;
        var options = this.getSearchOptions();

        // validate user-provided result scoring function
        if (settings.score) {
          calculateScore = self.settings.score.apply(this, [query]);
          if (typeof calculateScore !== 'function') {
            throw new Error('Selectize "score" setting must be a function that returns a function');
          }
        }

        // perform search
        if (query !== self.lastQuery) {
          self.lastQuery = query;
          result = self.sifter.search(query, extend(options, {
            score: calculateScore
          }));
          self.currentResults = result;
        } else {
          result = extend(true, {}, self.currentResults);
        }

        // filter out selected items
        if (settings.hideSelected) {
          for (i = result.items.length - 1; i >= 0; i -= 1) {
            if (self.items.indexOf(hash_key(result.items[i].id)) !== -1) {
              result.items.splice(i, 1);
            }
          }
        }

        return result;
      };

      /**
       * Refreshes the list of available options shown
       * in the autocomplete dropdown menu.
       *
       * @param {boolean} triggerDropdown
       */
      namespace.refreshOptions = function(triggerDropdown) {
        var i, j, k, n, groups, groups_order, option, option_html, optgroup, optgroups, html, html_children, has_create_option;
        var $active, $active_before, $create;

        if (typeof triggerDropdown === 'undefined') {
          triggerDropdown = true;
        }

        var self = this;
        var query = self.$control_input.value.trim();
        var results = self.search(query);
        var $dropdown_content = self.$dropdown_content;
        var active_before = self.$activeOption && hash_key(self.$activeOption.getAttribute('data-value'));

        // build markup
        n = results.items.length;
        if (typeof self.settings.maxOptions === 'number') {
          n = Math.min(n, self.settings.maxOptions);
        }

        // render and group available options individually
        groups = {};

        if (self.settings.optgroupOrder) {
          groups_order = self.settings.optgroupOrder;
          for (i = 0; i < groups_order.length; i += 1) {
            groups[groups_order[i]] = [];
          }
        } else {
          groups_order = [];
        }

        for (i = 0; i < n; i += 1) {
          option = self.options[results.items[i].id];
          option_html = self.render('option', option);
          optgroup = option[self.settings.optgroupField] || '';
          optgroups = isArray(optgroup) ? optgroup : [optgroup];

          for (j = 0, k = optgroups && optgroups.length; j < k; j += 1) {
            optgroup = optgroups[j];
            if (!self.optgroups.hasOwnProperty(optgroup)) {
              optgroup = '';
            }
            if (!groups.hasOwnProperty(optgroup)) {
              groups[optgroup] = [];
              groups_order.push(optgroup);
            }
            groups[optgroup].push(option_html);
          }
        }

        // render optgroup headers & join groups
        html = [];
        for (i = 0, n = groups_order.length; i < n; i += 1) {
          optgroup = groups_order[i];
          if (self.optgroups.hasOwnProperty(optgroup) && groups[optgroup].length) {
            // render the optgroup header and options within it,
            // then pass it to the wrapper template
            html_children = self.render('optgroup_header', self.optgroups[optgroup]) || '';
            html_children += groups[optgroup].join('');
            html.push(self.render('optgroup', extend({}, self.optgroups[optgroup], {
              html: html_children
            })));
          } else {
            html.push(groups[optgroup].join(''));
          }
        }

        Polymer.dom($dropdown_content).innerHTML = html.join('');

        // highlight matching terms inline
        if (self.settings.highlight && results.query.length && results.tokens.length) {
          for (i = 0, n = results.tokens.length; i < n; i += 1) {
            highlight($dropdown_content, results.tokens[i].regex);
          }
        }

        // add "selected" class to selected options
        if (!self.settings.hideSelected) {
          for (i = 0, n = self.items.length; i < n; i += 1) {
            self.getOption(self.items[i]).classList.add('selected');
          }
        }

        // add create option
        has_create_option = self.canCreate(query);
        if (has_create_option) {
          var tmp = document.createElement('div');
          var newNode = self.render('option_create', {
            input: query
          });
          Polymer.dom(tmp).innerHTML = newNode;
          Polymer.dom($dropdown_content).insertBefore(tmp.childNodes[0], $dropdown_content.childNodes[0]);
          $create = $dropdown_content.childNodes[0];
        }

        // activate
        self.hasOptions = results.items.length > 0 || has_create_option;
        if (self.hasOptions) {
          if (results.items.length > 0) {
            $active_before = active_before && self.getOption(active_before);
            if ($active_before && $active_before.length) {
              $active = $active_before;
            } else if (self.settings.mode === 'single' && self.items.length) {
              $active = self.getOption(self.items[0]);
            }
            //if (!$active || (!$active.length && !self.items.length)) {
            //    if ($create && !self.settings.addPrecedence) {
            //        $active = self.getAdjacentOption($create, 1);
            //    } else {
            //        $active = Polymer.dom($dropdown_content).querySelector('[data-selectable]'); //$dropdown_content.find('[data-selectable]:first');
            //    }
            //}
          } else {
            $active = $create;
          }
          self.setActiveOption($active);
          if (triggerDropdown && !self.isOpen && !self.isProgrammaticFocus) {
            self.open();
          }
        } else {
          self.setActiveOption(null);
          if (triggerDropdown && self.isOpen) {
            self.close();
          }
        }
      };

      /**
       * Adds an available option. If it already exists,
       * nothing will happen. Note: this does not refresh
       * the options list dropdown (use `refreshOptions`
       * for that).
       *
       * Usage:
       *
       *   this.addOption(data)
       *
       * @param {object} data
       */
      namespace.addOption = function(data) {
        var i, n, optgroup, value, self = this;

        if (isArray(data)) {
          for (i = 0, n = data.length; i < n; i += 1) {
            self.addOption(data[i]);
          }
          return;
        }

        value = hash_key(data[self.settings.valueField]);
        if (typeof value !== 'string' || self.options.hasOwnProperty(value)) {
          return;
        }

        self.userOptions[value] = true;
        self.options[value] = data;
        self.lastQuery = null;
        self.trigger('option_add', value, data);
      };

      /**
       * Registers a new optgroup for options
       * to be bucketed into.
       *
       * @param {string} id
       * @param {object} data
       */
      namespace.addOptionGroup = function(id, data) {
        this.optgroups[id] = data;
        this.trigger('optgroup_add', id, data);
      };

      /**
       * Updates an option available for selection. If
       * it is visible in the selected items or options
       * dropdown, it will be re-rendered automatically.
       *
       * @param {string} value
       * @param {object} data
       */
      namespace.updateOption = function(value, data) {
        var self = this;
        var $item, $item_new;
        var value_new, index_item, cache_items, cache_options;

        value = hash_key(value);
        value_new = hash_key(data[self.settings.valueField]);

        // sanity checks
        if (value === null) {
          return;
        }
        if (!self.options.hasOwnProperty(value)) {
          return;
        }
        if (typeof value_new !== 'string') {
          throw new Error('Value must be set in option data');
        }

        // update references
        if (value_new !== value) {
          delete self.options[value];
          index_item = self.items.indexOf(value);
          if (index_item !== -1) {
            self.items.splice(index_item, 1, value_new);
          }
        }
        self.options[value_new] = data;

        // invalidate render cache
        cache_items = self.renderCache.item;
        cache_options = self.renderCache.option;

        if (cache_items) {
          delete cache_items[value];
          delete cache_items[value_new];
        }
        if (cache_options) {
          delete cache_options[value];
          delete cache_options[value_new];
        }

        // update the item if it's selected
        if (self.items.indexOf(value_new) !== -1) {
          //debugger;
          $item = self.getItem(value);
          $item_new = self.render('item', data);
          if ($item.hasClass('active')) {
            $item_new.addClass('active');
          }
          $item.replaceWith($item_new);
        }

        //invalidate last query because we might have updated the sortField
        self.lastQuery = null;

        // update dropdown contents
        if (self.isOpen) {
          self.refreshOptions(false);
        }
      };

      /**
       * Removes a single option.
       *
       * @param {string} value
       */
      namespace.removeOption = function(value) {
        var self = this;
        value = hash_key(value);

        var cache_items = self.renderCache.item;
        var cache_options = self.renderCache.option;
        if (cache_items) {
          delete cache_items[value];
        }
        if (cache_options) {
          delete cache_options[value];
        }

        delete self.userOptions[value];
        delete self.options[value];
        self.lastQuery = null;
        self.trigger('option_remove', value);
        self.removeItem(value);
      };

      /**
       * Clears all options.
       */
      namespace.clearOptions = function() {
        var self = this;

        self.loadedSearches = {};
        self.userOptions = {};
        self.renderCache = {};
        self.options = self.sifter.items = {};
        self.lastQuery = null;
        self.trigger('option_clear');
        self.clear();
      };

      /**
       * Returns the jQuery element of the option
       * matching the given value.
       *
       * @param {string} value
       * @returns {object}
       */
      namespace.getOption = function(value) {
        var dropdownContent = this.$dropdown_content;
        var pddc = Polymer.dom(dropdownContent);
        var dataSelectables = pddc.querySelectorAll('[data-selectable]');
        var result = this.getElementWithValue(value, dataSelectables);
        return result;
      };

      /**
       * Returns the jQuery element of the next or
       * previous selectable option.
       *
       * @param {object} $option
       * @param {int} direction  can be 1 for next or -1 for previous
       * @return {object}
       */
      namespace.getAdjacentOption = function($option, direction) {
        var $options = Polymer.dom(this.$dropdown).querySelectorAll('[data-selectable]');
        var index = $options.indexOf($option) + direction;

        return index >= 0 && index < $options.length ? [$options[index]] : [];
      };

      /**
       * Added by ij
       * Returns the first item from the available items in the dropdown
       */
      namespace.getFirstItem = function() {
        var $options = this.$dropdown.querySelectorAll('[data-selectable]');
        return $options.length > 0 ? $options[0] : undefined;
      };

      /**
       * Finds the first element with a "data-value" attribute
       * that matches the given value.
       *
       * @param {mixed} value
       * @param {object} $els
       * @return {object}
       */
      namespace.getElementWithValue = function(value, $els) {
        var i, n;
        value = hash_key(value);

        if (typeof value !== 'undefined' && value !== null) {
          for (i = 0, n = $els.length; i < n; i += 1) {
            if ($els[i].getAttribute('data-value') === value) {
              return $els[i];
            }
          }
        }

        return [];
      };

      /**
       * Returns the jQuery element of the item
       * matching the given value.
       *
       * @param {string} value
       * @returns {object}
       */
      namespace.getItem = function(value) {
        return this.getElementWithValue(value, this.$control.children);
      };

      /**
       * "Selects" multiple items at once. Adds them to the list
       * at the current caret position.
       *
       * @param {string} value
       */
      namespace.addItems = function(values) {
        var items = isArray(values) ? values : [values];
        var i, n;
        for (i = 0, n = items.length; i < n; i += 1) {
          this.isPending = (i < n - 1);
          this.addItem(items[i]);
        }
      };

      namespace.updatePolymerElementValue = function() {
        //        if (this.settings && this.settings.polymerElement && this.settings.polymerElement._isReady) {
        //          this.settings.polymerElement.value = this.getValue();
        //        }
      };

      /**
       * "Selects" an item. Adds it to the list
       * at the current caret position.
       *
       * @param {string} value
       */
      namespace.addItem = function(value) {
        debounce_events(this, ['change'], function() {
          var $item, $option, $options;
          var self = this;
          var inputMode = self.settings.mode;
          var i, active, value_next, wasFull;
          value = hash_key(value);
          if (self.items.indexOf(value) !== -1) {
            if (inputMode === 'single') {
              self.close();
            }
            return;
          }

          if (!self.options.hasOwnProperty(value)) {
            return;
          }
          if (inputMode === 'single') {
            self.clear();
          }
          if (inputMode === 'multi' && self.isFull()) {
            return;
          }

          $item = self.render('item', self.options[value]);
          wasFull = self.isFull();
          self.items.splice(self.caretPos, 0, value);
          var insertedNode = self.insertAtCaret($item);
          self.reattachRemoveLinkClickEventListener(insertedNode);
          if (!self.isPending || (!wasFull && self.isFull())) {
            self.refreshState();
          }

          if (self.isSetup) {
            $options = Polymer.dom(self.$dropdown_content).querySelectorAll('[data-selectable]');

            // update menu / remove the option (if this is not one item being added as part of series)
            if (!self.isPending) {
              $option = self.getOption(value);
              var adjacentOption = self.getAdjacentOption($option, 1);
              value_next = adjacentOption.length > 0 ? adjacentOption[0].getAttribute('data-value') : undefined;
              self.refreshOptions(self.isFocused && inputMode !== 'single');
              if (value_next) {
                self.setActiveOption(self.getOption(value_next));
              }
            }

            // hide the menu if the maximum number of items have been selected or no options are left
            if (!$options.length || self.isFull()) {
              self.close();
            } else {
              self.positionDropdown();
            }

            self.updatePlaceholder();
            self.trigger('item_add', value, $item);
            self.updateOriginalInput();
          }
          self.updatePolymerElementValue();
        });
      };

      namespace.reattachRemoveLinkClickEventListener = function(insertedNode) {
        var removeItem = insertedNode.querySelector('.remove');
        if (removeItem !== null && removeItem !== undefined) {
          var __self = this;
          removeItem.addEventListener('click', function(e) {
            e.preventDefault();
            if (__self.isLocked) {
              return;
            }

            var $item = e.currentTarget.parentElement;
            __self.setActiveItem($item);
            if (__self.deleteSelection()) {
              __self.setCaret(__self.items.length);
            }
          });
          removeItem.addEventListener('touchstart', function(e) {
            e.preventDefault();
            if (__self.isLocked) {
              return;
            }

            var $item = e.currentTarget.parentElement;
            __self.setActiveItem($item);
            if (__self.deleteSelection()) {
              __self.setCaret(__self.items.length);
            }
          });
        }
      };

      /**
       * Removes the selected item matching
       * the provided value.
       *
       * @param {string} value
       */
      namespace.removeItem = function(value) {
        var self = this;
        var $item, i, idx;

        $item = (typeof value === 'object') ? value : self.getItem(value);
        if ($item.getAttribute !== undefined) {
          value = hash_key($item.getAttribute('data-value'));
        }
        i = self.items.indexOf(value);

        if (i !== -1) {
          $item.parentElement.removeChild($item); //Iremove();
          if ($item.classList.contains('active')) {
            idx = self.$activeItems.indexOf($item);
            self.$activeItems.splice(idx, 1);
          }

          self.items.splice(i, 1);
          self.lastQuery = null;
          if (!self.settings.persist && self.userOptions.hasOwnProperty(value)) {
            self.removeOption(value);
          }

          if (i < self.caretPos) {
            self.setCaret(self.caretPos - 1);
          }

          self.refreshState();
          self.updatePlaceholder();
          self.updateOriginalInput();
          self.positionDropdown();
          self.trigger('item_remove', value);
        }
      };

      /**
       * Invokes the `create` method provided in the
       * selectize options that should provide the data
       * for the new item, given the user input.
       *
       * Once this completes, it will be added
       * to the item list.
       *
       * @return {boolean}
       */
      namespace.createItem = function(triggerDropdown) {
        var self = this;
        var input = self.$control_input.value !== undefined ? self.$control_input.value.trim() : '';
        var caret = self.caretPos;
        if (!self.canCreate(input)) {
          return false;
        }
        self.lock();

        if (typeof triggerDropdown === 'undefined') {
          triggerDropdown = true;
        }

        var setup = (typeof self.settings.create === 'function') ? this.settings.create : function(input) {
          var data = {};
          data[self.settings.labelField] = input;
          data[self.settings.valueField] = input;
          return data;
        };

        var create = once(function(data) {
          self.unlock();

          if (!data || typeof data !== 'object') {
            return;
          }
          var value = hash_key(data[self.settings.valueField]);
          if (typeof value !== 'string') {
            return;
          }

          self.setTextboxValue('');
          self.addOption(data);
          self.setCaret(caret);
          self.addItem(value);
          self.refreshOptions(triggerDropdown && self.settings.mode !== 'single');
        });

        var output = setup.apply(this, [input, create]);
        if (typeof output !== 'undefined') {
          create(output);
        }

        return true;
      };

      /**
       * Re-renders the selected item lists.
       */
      namespace.refreshItems = function() {
        var i;
        this.lastQuery = null;

        if (this.isSetup) {
          for (i = 0; i < this.items.length; i += 1) {
            this.addItem(this.items);
          }
        }

        this.refreshState();
        this.updateOriginalInput();
      };

      /**
       * Updates all state-dependent attributes
       * and CSS classes.
       */
      namespace.refreshState = function() {
        var invalid, self = this;
        if (self.isRequired) {
          if (self.items.length) {
            self.isInvalid = false;
          }
          self.$control_input.setAttribute('required', invalid);
        }
        self.refreshClasses();
      };

      function toggleClass(element, className, toggle) {
        if (toggle) {
          element.classList.add(className);
        } else {
          element.classList.remove(className);
        }
      }

      function isEmptyObject(obj) {
        var name;
        for (name in obj) {
          if (obj.hasOwnProperty(name)) {
            return false;
          }
        }
        return true;
      }

      /**
       * Updates all state-dependent CSS classes.
       */
      namespace.refreshClasses = function() {
        var self = this;
        var isFull = self.isFull();
        var isLocked = self.isLocked;

        toggleClass(self.$wrapper, 'rtl', self.rtl);

        toggleClass(self.$control, 'focus', self.isFocused);
        toggleClass(self.$control, 'disabled', self.isDisabled);
        toggleClass(self.$control, 'required', self.isRequired);
        toggleClass(self.$control, 'invalid', self.isInvalid);
        toggleClass(self.$control, 'locked', isLocked);
        toggleClass(self.$control, 'full', isFull);
        toggleClass(self.$control, 'not-full', !isFull);
        toggleClass(self.$control, 'input-active', self.isFocused && !self.isInputHidden);
        toggleClass(self.$control, 'dropdown-active', self.isOpen);
        toggleClass(self.$control, 'has-options', !isEmptyObject(self.options));
        toggleClass(self.$control, 'has-items', self.items.length > 0);

        var dataGrowAttr = document.createAttribute('data-grow');
        dataGrowAttr.value = !isFull && !isLocked;
        self.$control_input.attributes.setNamedItem(dataGrowAttr);
      };

      /**
       * Determines whether or not more items can be added
       * to the control without exceeding the user-defined maximum.
       *
       * @returns {boolean}
       */
      namespace.isFull = function() {
        return this.settings.maxItems !== null && this.items.length >= this.settings.maxItems;
      };

      /**
       * Refreshes the original <select> or <input>
       * element to reflect the current state.
       */
      namespace.updateOriginalInput = function() {
        var i, n, options, self = this;

        if (self.tagType === TAG_SELECT) {
          options = [];
          for (i = 0, n = self.items.length; i < n; i += 1) {
            options.push('<option value="' + escape_html(self.items[i]) + '" selected="selected"></option>');
          }
          if (!options.length && !this.$input.getAttribute('multiple')) {
            options.push('<option value="" selected="selected"></option>');
          }
          Polymer.dom(self.$input).innerHTML = options.join('');
        } else {
          var value = self.getValue();
          if (isArray(value)) {
            value = value.join(',');
          }
          self.$input.setAttribute('value', value);
          self.$input.value = value;
        }

        if (self.isSetup) {
          var isInitializing = Boolean(self.isInitializing);
          if (!isInitializing) {
            self.trigger('change', self.get$InputValue());
          }
        }
      };

      /**
       * Helper function to get the value of the self.$input variable
       */
      namespace.get$InputValue = function() {
        if (this.$input.tagName === 'SELECT') {
          return this.getValue();
        } else {
          // self.$input.tagName is 'INPUT'
          return this.$input.value;
        }
      };

      /**
       * Shows/hide the input placeholder depending
       * on if there items in the list already.
       */
      namespace.updatePlaceholder = function() {
        if (!this.settings.placeholder) {
          return;
        }
        var $input = this.$control_input;

        if (this.items.length) {
          $input.removeAttr('placeholder');
        } else {
          $input.attr('placeholder', this.settings.placeholder);
        }
        $input.triggerHandler('update', {
          force: true
        });
      };

      /**
       * Shows the autocomplete dropdown containing
       * the available options.
       */
      namespace.open = function() {
        var self = this;

        if (self.isLocked || self.isOpen || (self.settings.mode === 'multi' && self.isFull())) {
          return;
        }
        self.focus();
        self.isOpen = true;
        self.refreshState();
        //self.$dropdown.css({ visibility: 'hidden', display: 'block' });
        self.$dropdown.style.visibility = 'hidden';
        self.$dropdown.style.display = 'block';
        self.positionDropdown();
        //self.$dropdown.css({ visibility: 'visible' });
        self.$dropdown.style.visibility = 'visible';
        self.trigger('dropdown_open', self.$dropdown);
      };

      /**
       * Closes the autocomplete dropdown menu.
       */
      namespace.close = function() {
        var self = this;
        var trigger = self.isOpen;

        if (self.settings.mode === 'single' && self.items.length) {
          self.hideInput();
        }

        self.isOpen = false;
        self.$dropdown.style.display = "none";
        self.setActiveOption(null);
        self.refreshState();

        if (trigger) {
          self.trigger('dropdown_close', self.$dropdown);
        }
      };

      /**
       * Calculates and applies the appropriate
       * position of the dropdown.
       */
      namespace.positionDropdown = function() {
        var $control = this.$control;
        var offset = this.settings.dropdownParent === 'body' ? $control.getBoundingClientRect() : {
          top: $control.offsetTop,
          left: $control.offsetLeft
        };
        offset.top += completeOuterHeight($control);

        this.$dropdown.style.width = '100%'; //$control.clientWidth + 'px';
        this.$dropdown.style.top = offset.top + 'px';
        this.$dropdown.style.left = offset.left + 'px';
      };

      /**
       * Resets / clears all selected items
       * from the control.
       */
      namespace.clear = function() {
        var self = this,
          i;

        if (!self.items.length) {
          return;
        }
        var children = self.$control.querySelectorAll(':not(input)');
        for (i = 0; i < children.length; i += 1) {
          var child = children[i];
          child.parentElement.removeChild(child);
          //          children[i].remove();
        }
        self.items = [];
        self.lastQuery = null;
        self.setCaret(0);
        self.setActiveItem(null);
        self.updatePlaceholder();
        self.updateOriginalInput();
        self.refreshState();
        self.showInput();
        self.trigger('clear');
      };

      /**
       * A helper method for inserting an element
       * at the current caret position.
       *
       * @param {object} $el
       */
      namespace.insertAtCaret = function($el) {
        var dummyDiv = document.createElement('div');
        Polymer.dom(dummyDiv).innerHTML = $el;
        var $elAsChild = dummyDiv.childNodes[0];

        var caret = Math.min(this.caretPos, this.items.length);
        if (caret === 0) {
          Polymer.dom(this.$control).insertBefore($elAsChild, this.$control_input);
        } else {
          var refElement = this.$control.childNodes[caret];
          Polymer.dom(this.$control).insertBefore($elAsChild, refElement);
        }
        this.setCaret(caret + 1);

        // *ij* something changed from polymer 0.8 to polymer 1.0
        // L1712: watchChildEvent is a hack for jquery
        // so now mousedown event listener needs to be applied here
        // when child is inserted an event listener should be attached
        var self = this;
        $elAsChild.addEventListener('mousedown', function() {
          self.onItemSelect.apply(self, arguments);
        });
        $elAsChild.addEventListener('touchstart', function() {
          self.onItemSelect.apply(self, arguments);
        });

        return $elAsChild;
      };

      /**
       * Removes the current selected item(s).
       *
       * @param {object} e (optional)
       * @returns {boolean}
       */
      namespace.deleteSelection = function(e) {
        var i, n, direction, selection, values, caret, option_select, $option_select, $tail;
        var self = this;

        direction = (e && e.keyCode === KEY_BACKSPACE) ? -1 : 1;
        selection = getSelection(self.$control_input);

        if (self.$activeOption && !self.settings.hideSelected) {
          var adjacentOptions = self.getAdjacentOption(self.$activeOption, -1);
          if (adjacentOptions.length > 0) {
            option_select = adjacentOptions[0].getAttribute('data-value');
          }
        }

        // determine items that will be removed
        values = [];

        if (self.$activeItems.length) {
          var $possibleTails = self.$control.querySelectorAll('.active');
          if ($possibleTails.length > 0 && direction > 0) {
            $tail = $possibleTails[$possibleTails.length - 1];
          } else {
            $tail = $possibleTails[0];
          }
          //$tail = self.$control.querySelectorAll('.active:' + (direction > 0 ? 'last' : 'first'));
          var notInputs = self.$control.querySelectorAll(':not(input)');
          caret = Array.prototype.indexOf.call(notInputs, $tail);

          if (direction > 0) {
            caret += 1;
          }

          for (i = 0, n = self.$activeItems.length; i < n; i += 1) {
            if (self.$activeItems[i] !== undefined) {
              var data_value = self.$activeItems[i].getAttribute('data-value');
              values.push(data_value);
            }
          }
          if (e) {
            e.preventDefault();
            e.stopPropagation();
          }
        } else if ((self.isFocused || self.settings.mode === 'single') && self.items.length) {
          if (direction < 0 && selection.start === 0 && selection.length === 0) {
            values.push(self.items[self.caretPos - 1]);
          } else if (direction > 0 && selection.start === self.$control_input.value.length) {
            values.push(self.items[self.caretPos]);
          }
        }

        // allow the callback to abort
        if (!values.length || (typeof self.settings.onDelete === 'function' && self.settings.onDelete.apply(self, [values]) === false)) {
          return false;
        }

        // perform removal
        if (typeof caret !== 'undefined') {
          self.setCaret(caret);
        }
        while (values.length) {
          self.removeItem(values.pop());
        }

        self.showInput();
        self.positionDropdown();
        self.refreshOptions(true);

        // select previous option
        if (option_select) {
          $option_select = self.getOption(option_select);
          if ($option_select.length) {
            self.setActiveOption($option_select);
          }
        }

        return true;
      };

      /**
       * Selects the previous / next item (depending
       * on the `direction` argument).
       *
       * > 0-right
       * <0-left
       *
       * @param {int} direction
       * @param {object} e (optional)
       */
      namespace.advanceSelection = function(direction, e) {
        var tail, selection, idx, valueLength, cursorAtEdge, $tail;
        var self = this;

        if (direction === 0) {
          return;
        }
        if (self.rtl) {
          direction *= -1;
        }

        tail = direction > 0 ? 'last' : 'first';
        selection = getSelection(self.$control_input);

        if (self.isFocused && !self.isInputHidden) {
          valueLength = self.$control_input.value.length;
          cursorAtEdge = direction < 0 ? selection.start === 0 && selection.length === 0 : selection.start === valueLength;

          if (cursorAtEdge && !valueLength) {
            self.advanceCaret(direction, e);
          }
        } else {
          var $tailItems = self.$control.querySelectorAll('.active');
          var $tailIndex = direction > 0 ? $tailItems.length - 1 : 0;
          $tail = $tailItems[$tailIndex];
          if ($tail !== undefined && $tail !== null) {
            var $control_children = self.$control.querySelectorAll(':not(input)');
            idx = $control_children.indexOf($tail);
            self.setActiveItem(null);
            self.setCaret(direction > 0 ? idx + 1 : idx);
          }
        }
      };

      /**
       * Moves the caret left / right.
       *
       * @param {int} direction
       * @param {object} e (optional)
       */
      namespace.advanceCaret = function(direction, e) {
        var self = this,
          fn,
          $adj;

        if (direction === 0) {
          return;
        }

        fn = direction > 0 ? 'next' : 'prev';
        if (self.isShiftDown) {
          $adj = self.$control_input[fn]();
          if ($adj.length) {
            self.hideInput();
            self.setActiveItem($adj);
            if (e) {
              e.preventDefault();
            }
          }
        } else {
          self.setCaret(self.caretPos + direction);
        }
      };

      /**
       * Moves the caret to the specified index.
       *
       * @param {int} i
       */
      namespace.setCaret = function(i) {
        var self = this;

        if (self.settings.mode === 'single') {
          i = self.items.length;
        } else {
          i = Math.max(0, Math.min(self.items.length, i));
        }

        if (!self.isPending) {
          // the input must be moved by leaving it in place and moving the
          // siblings, due to the fact that focus cannot be restored once lost
          // on mobile webkit devices
          var j, n, fn, $children, $child;
          //$children = self.$control.querySelectorAll(':not(input)');
          $children = self.$control.querySelectorAll('div');
          var $inputElement = self.$control.querySelector('input');
          for (j = 0, n = $children.length; j < n; j += 1) {
            $child = self.$control.removeChild($children[j]);
            if (j < i) {
              Polymer.dom(self.$control).insertBefore($child, $inputElement);
            } else {
              Polymer.dom(self.$control).appendChild($child);
            }
          }
        }

        self.caretPos = i;
      };

      /**
       * Disables user input on the control. Used while
       * items are being asynchronously created.
       */
      namespace.lock = function() {
        this.close();
        this.isLocked = true;
        this.refreshState();
      };

      /**
       * Re-enables user input on the control.
       */
      namespace.unlock = function() {
        this.isLocked = false;
        this.refreshState();
      };

      /**
       * Disables user input on the control completely.
       * While disabled, it cannot receive focus.
       */
      namespace.disable = function() {
        var self = this;
        self.$input.setAttribute('disabled', true);
        var $inputElement = self.$control.querySelector('input');
        // $inputElement.setAttribute('tabIndex', -1);
        //        self.$wrapper.classList.add('loading');
        self.isDisabled = true;
        self.lock();
      };

      /**
       * Enables the control so that it can respond
       * to focus and user input.
       */
      namespace.enable = function() {
        var self = this;
        self.$input.removeAttribute('disabled');
        var $inputElement = self.$control.querySelector('input');
        // $inputElement.setAttribute('tabIndex', 1);
        self.$wrapper.classList.remove('loading');
        self.isDisabled = false;
        self.unlock();
      };

      /**
       * Completely destroys the control and
       * unbinds all event listeners so that it can
       * be garbage collected.
       */
      namespace.destroy = function() {
        var self = this;
        var eventNS = self.eventNS;
        var revertSettings = self.revertSettings;
        var i;

        self.trigger('destroy');
        self.off();
        self.$wrapper.remove();
        self.$dropdown.remove();

        Polymer.dom(self.$input).innerHTML = '';
        for (i = 0; i < revertSettings.length; i += 1) {
          Polymer.dom(self.$input).appendChild(revertSettings.$children[i]);
        }
        self.$input.removeAttribute('tabindex');
        self.$input.classList.remove('selectized');
        // self.$input.setAttribute('tabindex', revertSettings.tabindex);
        self.$input.style.display = 'block';
        //self.$input
        //  .html('')
        //  .append(revertSettings.$children)
        //  .removeAttr('tabindex')
        //  .removeClass('selectized')
        //  .attr({ tabindex: revertSettings.tabindex })
        //  .show();

        self.$control_input.attributes.removeNamedItem('data-grow');
        root.removeData(self.$input, 'selectize');
        //self.$input.removeData('selectize');

        window.removeEventListener(eventNS);
        document.removeEventListener(eventNS);
        document.body.removeEventListener(eventNS);
        //$(window).off(eventNS);
        //$(document).off(eventNS);
        //$(document.body).off(eventNS);

        delete self.$input.selectize;
      };

      /**
       * A helper method for rendering "item" and
       * "option" templates, given the data.
       *
       * @param {string} templateName
       * @param {object} data
       * @returns {string}
       */
      namespace.render = function(templateName, data) {
        var value, id, label;
        var html = '';
        var cache = false;
        var self = this;
        var regex_tag = /^[\t ]*<([a-z][a-z0-9\-_]*(?:\:[a-z][a-z0-9\-_]*)?)/i;

        if (templateName === 'option' || templateName === 'item') {
          value = hash_key(data[self.settings.valueField]);
          cache = !!value;
        }

        //if (templateName === 'item') {
        //  cache = false;
        //}

        // pull markup from cache if it exists
        if (cache) {
          if (!isset(self.renderCache[templateName])) {
            self.renderCache[templateName] = {};
          }
          if (self.renderCache[templateName].hasOwnProperty(value)) {
            return self.renderCache[templateName][value];
          }
        }

        // render markup
        html = self.settings.render[templateName].apply(this, [data, escape_html]);

        // add mandatory attributes
        if (templateName === 'option' || templateName === 'option_create') {
          html = html.replace(regex_tag, '<$1 data-selectable');
        }
        if (templateName === 'optgroup') {
          id = data[self.settings.optgroupValueField] || '';
          html = html.replace(regex_tag, '<$1 data-group="' + escape_replace(escape_html(id)) + '"');
        }
        if (templateName === 'option' || templateName === 'item') {
          html = html.replace(regex_tag, '<$1 data-value="' + escape_replace(escape_html(value || '')) + '"');
        }

        // update cache
        if (cache) {
          self.renderCache[templateName][value] = html;
        }

        return html;
      };

      /**
       * Clears the render cache for a template. If
       * no template is given, clears all render
       * caches.
       *
       * @param {string} templateName
       */
      namespace.clearCache = function(templateName) {
        var self = this;
        if (typeof templateName === 'undefined') {
          self.renderCache = {};
        } else {
          delete self.renderCache[templateName];
        }
      };

      /**
       * Determines whether or not to display the
       * create item prompt, given a user input.
       *
       * @param {string} input
       * @return {boolean}
       */
      namespace.canCreate = function(input) {
        var self = this;
        if (!self.settings.create) {
          return false;
        }
        var filter = self.settings.createFilter;
        return input.length && (typeof filter !== 'function' || filter.apply(self, [input])) && (typeof filter !== 'string' || new RegExp(filter).test(input)) && (!(filter instanceof RegExp) || filter.test(input));
      };

    }(Selectize.prototype)); // end of selectize definition

    Selectize.count = 0;
    Selectize.defaults = {
      plugins: [],
      delimiter: ',',
      persist: true,
      diacritics: true,
      create: false,
      createOnBlur: false,
      createFilter: null,
      highlight: true,
      openOnFocus: true,
      maxOptions: 1000,
      maxItems: null,
      hideSelected: null,
      addPrecedence: false,
      selectOnTab: false,
      preload: false,
      allowEmptyOption: false,

      scrollDuration: 60,
      loadThrottle: 300,

      dataAttr: 'data-data',
      optgroupField: 'optgroup',
      valueField: 'value',
      labelField: 'title',
      optgroupLabelField: 'label',
      optgroupValueField: 'value',
      optgroupOrder: null,

      sortField: '$order',
      searchField: ['title'],
      searchConjunction: 'and',

      mode: null,
      wrapperClass: 'control',
      inputClass: 'input',
      dropdownClass: 'dropdown',
      dropdownContentClass: 'dropdown-content',

      dropdownParent: null,

      copyClassesToDropdown: true,

      /*
      load            : null, // function(query, callback) { ... }
      score           : null, // function(search) { ... }
      onInitialize    : null, // function() { ... }
      onChange        : null, // function(value) { ... }
      onItemAdd       : null, // function(value, $item) { ... }
      onItemRemove    : null, // function(value) { ... }
      onClear         : null, // function() { ... }
      onOptionAdd     : null, // function(value, data) { ... }
      onOptionRemove  : null, // function(value) { ... }
      onOptionClear   : null, // function() { ... }
      onDropdownOpen  : null, // function($dropdown) { ... }
      onDropdownClose : null, // function($dropdown) { ... }
      onType          : null, // function(str) { ... }
      onDelete        : null, // function(values) { ... }
      */

      render: {
        /*
        item: null,
        optgroup: null,
        optgroup_header: null,
        option: null,
        option_create: null
        */
      }
    };

    root.selectize = function(htmlElement, settings_user) {
      var defaults = root.selectize.defaults;
      var settings = extend({}, defaults, settings_user);
      var attr_data = settings.dataAttr;
      var field_label = settings.labelField;
      var field_value = settings.valueField;
      var field_optgroup = settings.optgroupField;
      var field_optgroup_label = settings.optgroupLabelField;
      var field_optgroup_value = settings.optgroupValueField;

      /**
       * Initializes selectize from a <input type="text"> element.
       *
       * @param {object} $input
       * @param {object} settings_element
       */
      var init_textbox = function($input, settings_element) {
        var i, n, values, option, value;
        value = $input && $input.value ? $input.value.trim() : '';
        if (!settings.allowEmptyOption && !value.length) {
          return;
        }

        values = value.split(settings.delimiter);
        for (i = 0, n = values.length; i < n; i += 1) {
          option = {};
          option[field_label] = values[i];
          option[field_value] = values[i];

          settings_element.options[values[i]] = option;
        }

        settings_element.items = values;
      };

      /**
       * Initializes selectize from a <select> element.
       *
       * @param {object} $input
       * @param {object} settings_element
       */
      var init_select = function($input, settings_element) {
        var i, n, tagName, $children, order = 0;
        var options = settings_element.options;

        var readData = function($el) {
          var data = attr_data && $el.getAttribute(attr_data);
          if (typeof data === 'string' && data.length) {
            return JSON.parse(data);
          }
          return null;
        };

        var addOption = function($option, group) {
          var value, option;

          //$option = $($option);

          value = $option.getAttribute('value') || '';
          if (!value.length && !settings.allowEmptyOption) {
            return;
          }

          // if the option already exists, it's probably been
          // duplicated in another optgroup. in this case, push
          // the current group to the "optgroup" property on the
          // existing option so that it's rendered in both places.
          if (options.hasOwnProperty(value)) {
            if (group) {
              if (!options[value].optgroup) {
                options[value].optgroup = group;
              } else if (!isArray(options[value].optgroup)) {
                options[value].optgroup = [options[value].optgroup, group];
              } else {
                options[value].optgroup.push(group);
              }
            }
            return;
          }

          option = readData($option) || {};
          option[field_label] = option[field_label] || $option.innerText;
          option[field_value] = option[field_value] || value;
          option[field_optgroup] = option[field_optgroup] || group;

          order += 1;
          option.$order = order;
          options[value] = option;

          if ($option.getAttribute('selected') === "selected") {
            settings_element.items.push(value);
          }
        };

        var addGroup = function($optgroup) {
          var i, n, id, optgroup, $options;

          $optgroup = $(optgroup);
          id = $optgroup.attr('label');

          if (id) {
            optgroup = readData($optgroup) || {};
            optgroup[field_optgroup_label] = id;
            optgroup[field_optgroup_value] = id;
            settings_element.optgroups[id] = optgroup;
          }

          $options = $('option', $optgroup);
          for (i = 0, n = $options.length; i < n; i += 1) {
            addOption($options[i], id);
          }
        };

        settings_element.maxItems = $input.getAttribute('multiple') ? null : 1;

        $children = $input.children;
        for (i = 0, n = $children.length; i < n; i += 1) {
          tagName = $children[i].tagName.toLowerCase();
          if (tagName === 'optgroup') {
            addGroup($children[i]);
          } else if (tagName === 'option') {
            addOption($children[i]);
          }
        }
      };

      if (htmlElement.selectize) {
        return htmlElement.selectize;
      }

      var instance;
      var $input = htmlElement;
      var tag_name = htmlElement.tagName.toLowerCase();
      var placeholder = $input.attributes.getNamedItem('placeholder') || $input.attributes.getNamedItem('data-placeholder');
      if (!placeholder && !settings.allowEmptyOption) {
        var emptyOption = $input.querySelector('option[value=""]');
        placeholder = emptyOption ? emptyOption.textContent : '';
      }

      var settings_element = {
        'placeholder': placeholder,
        'options': {},
        'optgroups': {},
        'items': []
      };

      if (tag_name === 'select') {
        init_select($input, settings_element);
      } else {
        init_textbox($input, settings_element);
      }

      instance = new Selectize($input, extend({}, defaults, settings_element, settings_user));
      return instance;
    };

    root.selectize.defaults = Selectize.defaults;

    // --------- Plugin definition --------- //
    Selectize.define('drag_drop', function(options) {
      if (!$.fn.sortable) {
        throw new Error('The "drag_drop" plugin requires jQuery UI "sortable".');
      }
      if (this.settings.mode !== 'multi') {
        return;
      }
      var self = this;

      self.lock = (function() {
        var original = self.lock;
        return function() {
          var sortable = self.$control.data('sortable');
          if (sortable) {
            sortable.disable();
          }
          return original.apply(self, arguments);
        };
      }());

      self.unlock = (function() {
        var original = self.unlock;
        return function() {
          var sortable = self.$control.data('sortable');
          if (sortable) {
            sortable.enable();
          }
          return original.apply(self, arguments);
        };
      }());

      self.setup = (function() {
        var original = self.setup;
        return function() {
          original.apply(this, arguments);

          var $control = self.$control.sortable({
            items: '[data-value]',
            forcePlaceholderSize: true,
            disabled: self.isLocked,
            start: function(e, ui) {
              ui.placeholder.css('width', ui.helper.css('width'));
              $control.css({
                overflow: 'visible'
              });
            },
            stop: function() {
              $control.css({
                overflow: 'hidden'
              });
              var active = self.$activeItems ? self.$activeItems.slice() : null;
              var values = [];
              $control.children('[data-value]').each(function() {
                values.push($(this).attr('data-value'));
              });
              self.setValue(values);
              self.setActiveItem(active);
            }
          });
        };
      }());
    }); // ----- end of drag_drop


    Selectize.define('dropdown_header', function(options) {
      var self = this;

      options = extend({
        title: 'Untitled',
        headerClass: 'dropdown-header',
        titleRowClass: 'dropdown-header-title',
        labelClass: 'dropdown-header-label',
        closeClass: 'dropdown-header-close',

        html: function(data) {
          return (
            '<div class="' + data.headerClass + '">' +
            '<div class="' + data.titleRowClass + '">' +
            '<span class="' + data.labelClass + '">' + data.title + '</span>' +
            '<a href="javascript:void(0)" class="' + data.closeClass + '">&times;</a>' +
            '</div>' +
            '</div>'
          );
        }
      }, options);

      self.setup = (function() {
        var original = self.setup;
        return function() {
          original.apply(self, arguments);
          self.$dropdown_header = $(options.html(options));
          self.$dropdown.prepend(self.$dropdown_header);
        };
      }());

    }); // ----- end of drag_drop

    Selectize.define('optgroup_columns', function(options) {
      var self = this;

      options = extend({
        equalizeWidth: true,
        equalizeHeight: true
      }, options);

      this.getAdjacentOption = function($option, direction) {
        var $options = $option.closest('[data-group]').find('[data-selectable]');
        var index = $options.index($option) + direction;

        return index >= 0 && index < $options.length ? $options.eq(index) : $();
      };

      this.onKeyDown = function() {
        var original = self.onKeyDown;
        return function(e) {
          var index, $option, $options, $optgroup;

          if (this.isOpen && (e.keyCode === KEY_LEFT || e.keyCode === KEY_RIGHT)) {
            self.ignoreHover = true;
            $optgroup = this.$activeOption.closest('[data-group]');
            index = $optgroup.find('[data-selectable]').index(this.$activeOption);

            if (e.keyCode === KEY_LEFT) {
              $optgroup = $optgroup.prev('[data-group]');
            } else {
              $optgroup = $optgroup.next('[data-group]');
            }

            $options = $optgroup.find('[data-selectable]');
            $option = $options.eq(Math.min($options.length - 1, index));
            if ($option.length) {
              this.setActiveOption($option);
            }
            return;
          }

          return original.apply(this, arguments);
        };
      };

      var getScrollbarWidth = function() {
        var div;
        var width = getScrollbarWidth.width;
        var doc = document;

        if (typeof width === 'undefined') {
          div = doc.createElement('div');
          div.innerHTML = '<div style="width:50px;height:50px;position:absolute;left:-50px;top:-50px;overflow:auto;"><div style="width:1px;height:100px;"></div></div>';
          div = div.firstChild;
          doc.body.appendChild(div);
          width = getScrollbarWidth.width = div.offsetWidth - div.clientWidth;
          doc.body.removeChild(div);
        }
        return width;
      };

      var equalizeSizes = function() {
        var i, n, height_max, width, width_last, width_parent, $optgroups;

        $optgroups = $('[data-group]', self.$dropdown_content);
        n = $optgroups.length;
        if (!n || !self.$dropdown_content.width()) {
          return;
        }

        if (options.equalizeHeight) {
          height_max = 0;
          for (i = 0; i < n; i += 1) {
            height_max = Math.max(height_max, $optgroups.eq(i).height());
          }
          $optgroups.css({
            height: height_max
          });
        }

        if (options.equalizeWidth) {
          width_parent = self.$dropdown_content.innerWidth() - getScrollbarWidth();
          width = Math.round(width_parent / n);
          $optgroups.css({
            width: width
          });
          if (n > 1) {
            width_last = width_parent - width * (n - 1);
            $optgroups.eq(n - 1).css({
              width: width_last
            });
          }
        }
      };

      if (options.equalizeHeight || options.equalizeWidth) {
        hook.after(this, 'positionDropdown', equalizeSizes);
        hook.after(this, 'refreshOptions', equalizeSizes);
      }

    }); // ------- end of optgroup_columns

    Selectize.define('remove_button', function(options) {
      if (this.settings.mode === 'single') {
        return;
      }

      options = extend({
        label: '&times;',
        title: 'Remove',
        className: 'remove',
        append: true
      }, options);

      var self = this;
      var html = '<a href="javascript:void(0)" class="' + options.className + '" tabindex="-1" title="' + escape_html(options.title) + '">' + options.label + '</a>';

      /**
       * Appends an element as a child (with raw HTML).
       *
       * @param {string} html_container
       * @param {string} html_element
       * @return {string}
       */
      var append = function(html_container, html_element) {
        var pos = html_container.search(/(<\/[^>]+>\s*)$/);
        return html_container.substring(0, pos) + html_element + html_container.substring(pos);
      };

      this.setup = (function() {
        var original = self.setup;
        var i;
        return function() {
          // override the item rendering method to add the button to each
          //debugger;
          if (options.append) {
            var render_item = self.settings.render.item;
            self.settings.render.item = function(data) {
              var result = append(render_item.apply(this, arguments), html);
              return result;
            };
          }
          original.apply(this, arguments);

          // add event listener
          var removeItems = this.$control.querySelectorAll('.' + options.className);
          for (i = 0; i < removeItems.length; i += 1) {
            removeItems[i].addEventListener('click', function(e) {
              e.preventDefault();
              if (self.isLocked) {
                return;
              }

              var $item = e.currentTarget.parentElement;
              self.setActiveItem($item);
              if (self.deleteSelection()) {
                self.setCaret(self.items.length);
              }
            });
            removeItems[i].addEventListener('touchstart', function(e) {
              e.preventDefault();
              if (self.isLocked) {
                return;
              }

              var $item = e.currentTarget.parentElement;
              self.setActiveItem($item);
              if (self.deleteSelection()) {
                self.setCaret(self.items.length);
              }
            });
          }
        };
      }());
    }); // ----- end of remove button

    Selectize.define('restore_on_backspace', function(options) {
      var self = this;

      options.text = options.text || function(option) {
        return option[this.settings.labelField];
      };

      this.onKeyDown = (function(e) {
        var original = self.onKeyDown;
        return function(e) {
          var index, option;
          if (e.keyCode === KEY_BACKSPACE && this.$control_input.val() === '' && !this.$activeItems.length) {
            index = this.caretPos - 1;
            if (index >= 0 && index < this.items.length) {
              option = this.options[this.items[index]];
              if (this.deleteSelection(e)) {
                this.setTextboxValue(options.text.apply(this, [option]));
                this.refreshOptions(true);
              }
              e.preventDefault();
              return;
            }
          }
          return original.apply(this, arguments);
        };
      }());
    });

    return Selectize;
  })); // end of atfromlookup definition
</script>
