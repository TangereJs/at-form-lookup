<link rel="import" href="../tangere/tangere.html">
<link rel="import" href="../at-theme/at-theme.html">
<link rel="import" href="../at-i18n/at-i18n-behavior.html">
<link rel="import" href="../at-form-behaviors/at-form-behaviors.html">
<link rel="import" href="../at-core-activity/at-core-activity.html" />
<link rel="import" href="../iron-label/iron-label.html">
<link rel="import" href="../at-core-view/at-core-view.html">
<link rel="import" href="../at-core-dropdown/at-core-dropdown.html" />
<link rel="import" href="at-form-lookup-input-validation-behavior.html">
<link rel="import" href="at-form-lookup-styles.html">
<link rel="import" href="../at-core-spinner/at-core-spinner.html" />
<link rel="import" href="../at-carbon-message/at-carbon-message.html" />
<link rel="import" href="items-view.html" />
<link rel="import" href="options-view.html" />

<dom-module id="at-form-lookup">
  <template>
    <style include="at-form-common"></style>
    <style>
      :host {
        @apply(--at-form-host);
        box-sizing: border-box;
      }

      .at-content-container {
        @apply(--at-form-input-common);
      }

      [focused].at-content-container {
        @apply(--at-form-input-focus);
      }
    </style>
    
    <at-core-activity id="coreAjax" url="[[url]]" on-response="_handleCoreAjaxOnResponse" on-error="_handleCoreAjaxOnError"></at-core-activity>
    <at-core-spinner id="coreSpinner"></at-core-spinner>
    <at-carbon-message id="carbonMessage" type="info"></at-carbon-message>
    
    <div id="atContainer" class="at-container" hidden>
        <!--
        Introduced label container as a workaround for a bug with opacity calculation in polymer-js
        Right now, if opacity is changed via js by setting a disabled class on iron-label, iron-label is not styled correctly
        And changing its text also doesn't work correctly when disabled class is set
        In the workaround, disabled class is set on the container.
      -->
      <div id="labelContainer">
        <iron-label id="label" on-tap="focus">{{label}}</iron-label>
      </div>
      
      <div id="contentContainer" class="at-content-container">
        <items-view id="itemsView" multiple$="[[_computeMultiple(maxItems)]]"></items-view>
      </div>

      <at-core-dropdown id="coreDropdown" no-mask y-offset="7">
        <options-view id="optionsView" item-view="[[itemView]]"></options-view>
      </at-core-dropdown>

      <div id="hint" class="hint"></div>
    </div>
  </template>
</dom-module>
<script>
  'use strict';
  Polymer({
    is: 'at-form-lookup',
    behaviors: [ Tangere.behaviors.i18n, Tangere.behaviors.formUIGeneric, Tangere.behaviors.AtFormLookupInputValidation ],

    properties: {
      /**
       * Element's label for element display purposes
       * @property label
       * @type String
       * @default ""
       */
      label: {
        type: String,
        value: '',
        title: 'Label'
      },

      /**
       * Hides label when true
       * @property hideLabel
       * @type Boolean
       * @default false
       */
      hideLabel: {
        type: Boolean,
        value: false,
        observer: '_hideLabelChanged',
        title: 'Do not show the label'
      },

      /**
       * Element's disabled state
       * @property disabled
       * @type Boolean
       * @default false
       */
      disabled: {
        type: Boolean,
        value: false,
        observer: '_disabledChanged',
        title: 'Field value can not be changed'
      },

      /**
       * Hides the element. When hidden nothing is displayed for the element
       * @property hide
       * @type Boolean
       * @default false
       */
      hide: {
        type: Boolean,
        value: false,
        observer: '_hideChanged',
        title: 'Field is invisible'
      },

      /**
       * Element's required state for element validation purposes
       * @property required
       * @type Boolean
       * @default false
       */
      required: {
        type: Boolean,
        value: false,
        title: 'Input required'
      },

      /**
       * The list of items that should initially be present for selection
       * value should be provided as a comma separated values (CSV) string
       * @property available
       * @type String
       * @default ""
       */
      available: {
        type: String,
        value: ''
      },
      // ------------------------------------------------------------
      // "Why is xvaluelist here?" - you ask.
      // "We already have available just above" - you say.
      // xvaluelist is here to improve compatibility with copyProperties function in at-core-form/script/schema-helpers.js
      // this function goes through element properties and copies property values from property definition in json schema to element properties
      // now available doens't exist in property definition in json schema so undefined will be copied
      // xvaluelist exists in json schema and when property name is valuelist, xvaluelist should be copied
      // so we introduce xvaluelist property in at-form-radio to remove if statement that would detect this situation
      // ------------------------------------------------------------
      /**
       * The list of items that should initially be present for selection
       * value should be provided as an array of title, value objects
       * @property xvaluelist
       * @type Array
       * @default []
       */
      xvaluelist: {
        type: Array,
        value: function() {
          return [];
        },
        schema: {
          items: {
            type: "object",
            properties: {
              title: {
                "type": "string"
              },
              value: {
                type: "string"
              }
            }
          }
        },
        layout: 'horizontal',
        xgridcols: '12',
        title: 'Value List'
      },
      // ------------------------------------------------------------
      // "Why is enum here?" - you ask.
      // "We already have available and xvaluelist just above" - you say.
      // read explanation for xvaluelist, enum is here for the same reason
      // ------------------------------------------------------------
      /**
       * The list of items that should initially be present for selection
       * value should be provided as an array of strings
       * @property enum
       * @type Array
       * @default []
       */
      enum: {
        type: Array,
        value: function() {
          return [];
        },
        schema: {
          items: {
            type: "string",
            properties: {
              value: {
                type: "string"
              }
            }
          }
        },
        layout: 'horizontal',
        title: 'Values'
      },

      /**
       * Elements value. Value is a CSV string
       * @property value
       * @type String
       * @default empty string
       */
      value: {
        type: String,
        value: '',
        title: 'Value'
      },

      /**
       * initialSearchTerm - when set/changed the current values are cleared and it behaves like having typed that value
       * @property initialSearchTerm
       * @type String
       * @default ""
       */
      initialSearchTerm: {
        type: String,
        value: "",
        title: 'Initial Search Term'
      },

      /**
       * Elements value as an array of selected objects
       * @property selectedItems
       * @type Array
       * @default []
       */
      selectedItems: {
        type: Array,
        value: function () {
          return [];
        },
        xtype: 'json',
        readOnly: true
      },

      /**
       * When true no authentication is sent to the server
       * @property noCredentials
       * @type Boolean
       * @default false
       */
      noCredentials: {
        type: Boolean,
        value: false
      },

      /**
       * When true initial request to popluate the available items is not set
       * @property noPreload
       * @type Boolean
       * @default false
       */
      noPreload: {
        type: Boolean,
        value: false
      },

      /**
       * Remote url from where to get items from
       * @property url
       * @type String
       * @default ""
       */
      url: {
        type: String,
        value: '',
        title: 'Url'
      },

      /**
       * Remote url from where to get items from
       * @property xurl
       * @type String
       * @default ""
       */
      xurl: {
        type: String,
        value: ''
      },

      /**
       * Additional params to send with each request
       * @property params
       * @type String
       * @default ""
       */
      params: {
        type: String,
        value: ''
      },

      /**
       * When true new entries are created when no matching record is found
       * @property allowNewItems
       * @type Boolean
       * @default false
       */
      allowNewItems: {
        type: Boolean,
        value: false,
        title: 'Allow new entries'
      },

      /**
       * Maximum count of items that can be selected
       * @property maxItems
       * @type Number
       * @default 1
       */
      maxItems: {
        type: Number,
        value: 1,
        title: 'Maximum number of selectable items'
      },

      /**
       * Liquid template to render options in the dropdown with
       * 
       * @property itemView
       * @type String
       * @default ''
       */
      itemView: {
        type: String,
        title: "Item view",
        value: '',
        xtype: "code",
        mode: "carbon"
      },

      /**
       * view model objects that holds internal state of the element
       * 
       * @property _viewModel
       * @type Object
       * @default {}
       */
      _viewModel: {
        type: Object,
        value: function() {
          return {
            // original options are options given in .availble, .enum or .xvaluelist for local data
            // or received from remoteUrl for remote data
            // original options are used to compute .value based on selected options (in items-view.items)
            // and to compute .selectedItems based on selected options (again items-view.items)
            originalOptions: [],
            // available options are options available to be displayed in dropdown
            // available option is an object with title and value properties
            // title is title of original option, value is index in original options array (to support computation of value and selectedItems)
            // filtering is done on available options 
            // selecting an option from dropdown transfers it to items-view.items
            // removing an option from items-view moves it back to available options
            availableOptions: [],
            initialItems: []
          };
        }
      }

    },

    $meta: [{
      title: "Enum",
      type: "string",
      xtype: "enum"
    }, {
      title: "Lookup",
      type: "string",
      xtype: "lookup"
    }],

    observers: [
      '_internalValidStateUpdate(required, errorMessage, value)',
      '_initializeLookup(available, enum, xvaluelist, value, url, xurl, noCredentials, noPreload, params, initialSearchTerm, maxItems, _viewModel)'
    ],

    _hideLabelChanged: function(newValue, oldValue) {
      this.toggleClass("hidden", newValue, this.$.label);
    },

    // computes multiple attribute for items-view
    _computeMultiple: function(maxItems) {
      var value = parseInt(maxItems);
      if (isNaN(value)) {
        value = 0;
      }
      return value !== 1;
    },

    ready: function() {

      // *ij* 17.06.2016 (dd.mm.yyyy)
      // there is a requirement for 'required' at-form-*elements that they initially be displayed
      // as valid event when they are initially invalid;
      // on first focus/blur sequence they should be displayed as invalid
      // code bellow provides for display as invalid on first focus/blur sequence
      // this was discovered with unit testing
      var self = this;
      var focusable = this._getFocusableElement();
      if (focusable) {
        focusable.addEventListener('blur', function(event) {
          self.validate();
        });
      }

      // call into at-form-behaviors.formUIGeneric._attachFocusBlurEvents
      this._attachFocusBlurEvents();

      // reference to lookup instance is given to items view so that focus/blur handling can be turned off when moving input field left and right
      this.$.itemsView._lookupInstance = this;
    },

    attached: function() {
      this._boundWidnowScrollEventHandler = this._handleWindowScrollEvent.bind(this);
      // we want to close the dropdown on scroll or resize
      window.addEventListener('scroll', this._boundWidnowScrollEventHandler);
      window.addEventListener('resize', this._boundWidnowScrollEventHandler);

      if (this._isInitialized) {
        this._setupEventListeners();
      }
    },

    detached: function() {
      // cleanup
      window.removeEventListener('scroll', this._boundWidnowScrollEventHandler);
      window.removeEventListener('resize', this._boundWidnowScrollEventHandler);

      this._detachEventListeners();
    },

    _handleWindowScrollEvent: function() {
      // close the dropdown
      this._closeDropdown();
    },

    _disabledChanged: function(newValue, oldValue) {
      this.toggleClass('disabled', newValue, this.$.labelContainer);

      this.toggleAttribute('disabled', newValue, this.$.itemsView);
    },

    _hideChanged: function(newValue, oldValue) {
      this.toggleClass('hidden', newValue, this.$.atContainer);
    },

    _internalValidStateUpdate: function (required, errorMessage) {
      this.validate();
    },

    validate: function (showError) {
      if (showError === undefined) { showError = this.autoValidate; }

      var validationResult = this._validateBaseData();
      this._handleValidationResult(validationResult);
      if (!validationResult.isValid) {
        return validationResult.isValid;
      }

      validationResult = this._validateData(this, this.value, this.T.bind(this));
      if(showError) this._handleValidationResult(validationResult);
      if (!validationResult.isValid) {
        return validationResult.isValid;
      }
      /*
        if user typed text into text input but didn't select an item we
        1) do not want text to be deleted
        2) we want to display a validation error message if user typed but didn't select an item
        * this.$.itemsView.$.filterTextInput.value contains value that user typed
        * this.value is empty if user didn't select an item
       */
      var userTypedText = this._getInput().value;
      if (
        userTypedText.length && // if user typed text
        !this.value.length // but didn't select a value
      ) {
        // report the error
        validationResult.isValid = false;
        validationResult.errorMessage = this.T("Please select a record");
      } else {
        validationResult.isValid = true;
      }
      if (showError) this._handleValidationResult(validationResult);

      return validationResult.isValid;
    },

    _updateUIValidState: function(isValid) {
      var label = this.$.label;
      this.toggleClass('error', !isValid, label);
      var contentContainer = this.$.contentContainer;
      this.toggleClass('error', !isValid, contentContainer);
    },

    // this function can not be called _initialize because in at-i18n-behavior there is a function called _initialize. if this function is called _initialize then at-i18n will call this function instead of at-i18n initialize
    _initializeLookup: function(available, enumarr, xvaluelist, value, url, xurl, noCredentials, noPreload, params, initialSearchTerm, maxItems) {
      // this is required when value is updated and value-changed event fired
      if (this._skipInitialization) return;

      var self = this;
      var initRemoteMode = xurl || url;

      if (!initRemoteMode) {
        if (this._lastUsedUrl) { this._lastUsedUrl = undefined; }
        
        // 1. let url be set 
        // 2. let value be set to lorem
        // 3. let value be changed to ipsum
        // 4. let url be set to ''
        // item 3. will start the debouncer, but item 4. will switch lookup to local data source mode
        // in this case we need to cancel the debounce
        this.cancelDebouncer('initialize-remote');
        
        this._initializeLocalDataSource(available, enumarr, xvaluelist, value, initialSearchTerm, maxItems);
        this._isInitialized = true;

      } else {
        this.debounce('initialize-remote', function() {
          this._initializeRemoteDataSource(url, xurl, noCredentials, noPreload, params, value, initialSearchTerm, maxItems);
          this._isInitialized = true;
        }.bind(this), 150);
      }
    },

    _initializeLocalDataSource: function(available, enumarr, xvaluelist, value, initialSearchTerm, maxItems) {

      // 1. compute available options      
      var availableOptions = [];
      if (xvaluelist && xvaluelist.length) {
        availableOptions = xvaluelist;
      } else if (enumarr && enumarr.length) {
        availableOptions = enumarr;
      } else if (isString(available) && available.length) {
        availableOptions = available;
      }

      var vmOptions = [];

      function isArray(obj) { return Object.prototype.toString.apply(obj) === "[object Array]"; }
      function isString(obj) { return Object.prototype.toString.apply(obj) === "[object String]"; }
      function isObject(obj) { return Object.prototype.toString.apply(obj) === "[object Object]"; }
      function isCommaSeparated(obj) { return isString(obj) && obj.indexOf(',') > -1; }

      if (isArray(availableOptions)) {
        availableOptions.forEach(function(option) {
          if (isString(option)) {
            option = option.trim();
            vmOptions.push({
              title: option,
              value: option
            });
          } else if (isObject(option)) {
            vmOptions.push({
              title: option.title ? option.title : option.value,
              value: option.value,
              itemRef: option
            });
          }
        });

      } else if (isCommaSeparated(availableOptions)) {
        availableOptions = availableOptions.split(',');
        availableOptions.forEach(function(option) { 
          option = option.trim();
          vmOptions.push({
            title: option,
            value: option
          });
        });
      }

      // NOTE(ij): we need to have originalOptions set before updating selected items becuase updating selected items requires populated original options
      // save vmOptions as original options in _viewModel
      this._viewModel.originalOptions = JSON.parse(JSON.stringify(vmOptions));

      // 2. put available options into options-view
      // delay until value is processed, so already selected options are removed
      // delay until initialSearchTerm is processed, so that remaining items are filtered and highlighted
      function isFunction(obj) { return Object.prototype.toString.apply(obj) === "[object Function]"; }
      if (!isString(value)) {
        value = isFunction(value) ? "" : String(value);
      }

      // 3. compute initially selected items based on value
      if (isString(value)) {
        // value is a csv string
        var valueParts = value.split(',');
        var selectedOptions = [];
        
        for (var i = 0; i < valueParts.length; i++) {
          var vmOption = null;
          var valuePart = valueParts[i];
          valuePart = valuePart.trim();
          var found = false;
          for (var j = 0; j < vmOptions.length && !found; j++) {
            vmOption = vmOptions[j];
            found = String(vmOption.value) === valuePart;
          }

          if (found) {
            selectedOptions.push(vmOption);
          }
        }

        if (maxItems === 1) {
          selectedOptions.splice(1);
          
        } else {
          if (maxItems > 1) {
            selectedOptions.splice(maxItems, selectedOptions.length - maxItems);
          }
        }

        this.$.itemsView.items = selectedOptions;

        this._updateLookupSelectedItems();

        if (this.autoValidate) { this.validate(); }
        
        this.fire('value-changed', { value: value }, { bubbles: false });

      } else {

        this._updateLookupSelectedItems();

        // value is null, undefined or else
        if (this.autoValidate) { this.validate(); }

        this.fire('value-changed', { value: value }, { bubbles: false });
      }

      // 4. put initalSearchTerm into filterTextInput
      this._getInput().value = initialSearchTerm;      
      this.$.itemsView._updateFilterTextInputWidth();

      // save unfiltered and non highlighted options as _viewModel available options
      this._viewModel.availableOptions = this._computeAvailableOptionsFromOriginalOptions();

      // do filter and highlight
      var filteredOptions = this._filterAndHighlightOptions(initialSearchTerm);
      this.$.optionsView.items = filteredOptions;

      // 5. hide the spinner
      this.$.coreSpinner.display = 'none';

      // 6. show the element
      this.$.atContainer.removeAttribute('hidden');

      // 7. attach relevant events
      this._setupEventListeners();
    },

    _initializeRemoteDataSource: function(url, xurl, noCredentials, noPreload, params, value, initialSearchTerm, maxItems) {
      // set inital requests completed state
      this._viewModel.optionsRequestComplete = true;
      this._viewModel.itemsRequestsComplete = true;

      // 1. compute available options
      var remoteUrl = xurl || url;
      
      // do not send new request if lastUsedUrl is the same as current remoteUrl
      var currUrl = {
        url: url,
        xurl: xurl,
        noCredentials: noCredentials,
        parmas: params,
        initialSearchTerm: initialSearchTerm
      };
      var currUrlStr = JSON.stringify(currUrl);

      if (!this._lastUsedUrl || (this._lastUsedUrl !== currUrlStr)) {
        this._lastUsedUrl = currUrlStr;

        // clear selected items from itemView
        this.$.itemsView.set('items', []);
        this._updateLookupValue('');
        this._fireValueChangedEvent();

        if (!noPreload) {
          // preload data; go to remote url with noCredentials and params and receive results
          this._sendRequestToQueryOptions(remoteUrl, initialSearchTerm);
        }
      }

      // 3. load initially selected from remote url based on value
      if (!this._boundInitialValueActivityResponseHandler) {
        this._boundInitialValueActivityResponseHandler = this._handleInitialValueActivityResponse.bind(this);
      }

      if (!this._boundInitialValueActivityErrorHanlder) {
        this._boundInitialValueActivityErrorHanlder = this._handleInitialValueActivityError.bind(this);
      }

      function isString(obj) { return Object.prototype.toString.apply(obj) === "[object String]"; }
      function isFunction(obj) { return Object.prototype.toString.apply(obj) === "[object Function]"; }
      if (!isString(value)) {
        value = isFunction(value) ? "" : String(value);
      }

      if (isString(value) && value.length) {
        // if this.value is not string variable value already contains this.value converted to string; do not switch back to this.value

        // if current value is the same as _lastUsedValue do not send requests
        if (!this._lastUsedValue || this._lastUsedValue !== value) {
          this._lastUsedValue = value;
          var baseAndQuery = this._computeBaseUrlAndQueryParams(remoteUrl);

          // value is a csv string
          var valueParts = value.length ? value.split(',') : [];
          this._viewModel.initialValueRequestsQueue = [];
          this._viewModel.initialValueActivitiesQueue = [];

          valueParts.forEach(function(part, index) { 
            part = part.trim();
            // ignore empty parts
            if (!part) { 
              console.log('initial value csv string has empty value at zero-based index of ' + index);
              return;
            }

            var partUrl = baseAndQuery.baseUrl + '/' + part;
            var partCoreActivity = document.createElement('at-core-activity');
            partCoreActivity.url = partUrl;
            baseAndQuery.queryParams.forEach(function(queryParam) {
              partCoreActivity.params[queryParam.name] = queryParam.value;
            });
            partCoreActivity.noCredentials = noCredentials;
            partCoreActivity.addEventListener('response', this._boundInitialValueActivityResponseHandler);
            partCoreActivity.addEventListener('error', this._boundInitialValueActivityErrorHanlder);
            this._viewModel.initialValueActivitiesQueue.push(partCoreActivity);
            this._viewModel.initialValueRequestsQueue.push({
              requestedItemId: part,
              isCompleted: false,
              item: undefined
            })
          }, this);

          this._viewModel.itemsRequestsComplete = false;
          this._viewModel.initialValueActivitiesQueue.forEach(function(a) {
            a.generateRequest();
          });
        }

      } else {
        if (!isString(value)) {
          console.log('type of value is ' + (typeof value));
        }
      }

      // 4. put initalSearchTerm into filterTextInput
      this._getInput().value = initialSearchTerm;
      this.$.itemsView._updateFilterTextInputWidth();

      // 5. hide the spinner
      this.$.coreSpinner.display = 'none';

      // 6. show the element
      this.$.atContainer.removeAttribute('hidden');

      // 7. attach relevant events
      this._setupEventListeners();
    },

    _sendRequestToQueryOptions: function(remoteUrl, query) {
      var baseAndQuery = this._computeBaseUrlAndQueryParams(remoteUrl);
      var coreAjax = this.$.coreAjax;

      coreAjax.url = baseAndQuery.baseUrl;

      baseAndQuery.queryParams.forEach(function(queryParam) {
        coreAjax.params[queryParam.name] = queryParam.value;
      });

      // handle lookup.params property
      // lookup.params is a string; the string must be a json string
      if (this.params && this.params.length) {
        try {
          var paramsObj = JSON.parse(this.params);
          var paramsObjKeys = Object.keys(paramsObj);
          paramsObjKeys.forEach(function(paramName) {
            paramName = window.encodeURIComponent(paramName);
            coreAjax.params[paramName] = window.encodeURIComponent(paramsObj[paramName]);
          });

        } catch(e) {
          console.log('params string ' + this.params + ' is not a valid json string');
        }
      }

      coreAjax.params["query"] = query;
      coreAjax.params["page"] = 1;
      coreAjax.params["pageSize"] = 25;

      coreAjax.noCredentials = this.noCredentials;

      this.fire('at-form-lookup-beforeAjax', {
        coreAjax: coreAjax,
        query: query
      }, { bubbles: false });

      // disable the lookup element
      this.disabled = true;

      this._viewModel.optionsRequestComplete = false;
      coreAjax.generateRequest();
    },

    _handleCoreAjaxOnError: function(event) {
      var q = this._viewModel.initialValueRequestsQueue;
      if (q && q.length) return;
      this.disabled = false;

      // _sync options and items
      this._viewModel.optionsRequestComplete = true;
      this._syncOptionsAndItemsRequests();
    },

    _handleCoreAjaxOnResponse: function(event) {
      // extract the data from the event
      var eventObject = {
        response: event.detail,
        returnData: []
      };
      this.fire('at-form-lookup-afterAjax', eventObject, { bubbles: false });
      var availableOptions = [];

      if (!eventObject.returnData.length) {
        // process data from at-core-activity
        var response = event.detail;
        if (response.Data && response.Data.items) {
          // save response.Data.items in _viewModel
          this._viewModel.remoteData = response.Data.items;

          response.Data.items.forEach(function(item, index) {
            // we create an option object that will be used internally for dropdown, selection, search and highlighting, where itemRef points to original object returned from server
            availableOptions.push({
              title: item.title,
              value: item.id,
              itemRef: item
            });
          });
        }

      } else {
        // use data that 3rd party provided
        var availableOptions = eventObject.returnData;
      }

      this._viewModel.originalOptions = availableOptions;

      // 2. put available options into options-view
      this._viewModel.availableOptions = this._computeAvailableOptionsFromOriginalOptions();

      // _sync options and items
      this._viewModel.optionsRequestComplete = true;
      this._syncOptionsAndItemsRequests();

      var filterText = this._getInput().value;
      // _filterAndHighlight will return a clone of availableOptions for empty filter text
      var filteredOptions = this._filterAndHighlightOptions(filterText);
      this.$.optionsView.set('items', filteredOptions);

      if (!this._viewModel.initialValueRequestsQueue || !this._viewModel.initialValueRequestsQueue.length) {
        this.disabled = false;

        if (this._viewModel.openDropdownOnResponse) {
          this._viewModel.openDropdownOnResponse = false;
          this._openDropdown();
          this._getInput().focus();
        }
      }
    },

    _handleInitialValueActivityError: function(event) {
      // NOTE(ij): if an error occurred for a request we need to handle it in the same way
      // as the invalid response
      this._handleInvalidResponse(event);
    },

    _isArray: function(obj) {
      return Object.prototype.toString.apply(obj) === "[object Array]";
    },

    _countIncompleteRequests: function(requestsQueue) {
      var count = 0;
      requestsQueue.forEach(function(req) {
        if (!req.isCompleted) count++;
      });
      return count;
    },

    _handleInvalidResponse: function(response) {
      // NOTE(ij): if the returned item from server doesn't have id property, we can't use it 
      // Its nonsense that I request an item from ther server by Id and do not get that id back for cross-reference especially when I have to fetch multiple items and have to match requests and responses
      // So, I put such items into _viewMode.invalidItems;
      if (!this._viewModel.invalidItems) this._viewModel.invalidItems = [];
      this._viewModel.invalidItems.push(response);

      // NOTE cont.(ij): if count of invalid items is the same as count of incomplete requests that means 
      // that we got all responses and we should initalize with any valid data available
      var sentRequestsQueueLength = this._viewModel.initialValueRequestsQueue.length;
      var invalidItemsCount = this._viewModel.invalidItems.length;
        
      if (invalidItemsCount === 1 && sentRequestsQueueLength === 1) {
        // there was only one request and that request produced invalid data in response
        this._handleInitialRequestsQueueComplete(response);
      
      } else { 
        // there are several requests
        var incompleteRequestsCount = this._countIncompleteRequests(this._viewModel.initialValueRequestsQueue);

        if (invalidItemsCount === incompleteRequestsCount) {
          this._handleInitialRequestsQueueComplete(response);
        }
      }
    },

    _handleInitialValueActivityResponse: function(event) {
      var item = event.detail.Data;
      var i; 
      var tmpReq;
      var ivRequest = false;

      // NOTE(ij): while testing with ItemPickerField I noticed that when requesting a specific item from an url I get array with length of 1 as result
      // http://localhost:2014/api/adenin.GateKeeper.Connector/ToasterDemo/Feed/1054979 returns
      // event.detail.Data.items.length === 1 where event.detail.Data.items[0] is the actual item requested
      if (item.items !== undefined && this._isArray(item.items) && item.items.length > 0) {
        item = item.items[0];

      } else if (!item.id) {
        item.id = -1;
      }

      for (var i = 0; i < this._viewModel.initialValueRequestsQueue.length && !ivRequest; i++) {
        var tmpReq = this._viewModel.initialValueRequestsQueue[i];
        ivRequest = tmpReq.requestedItemId.toString() === item.id.toString() ? tmpReq : ivRequest;
      }

      if (!ivRequest) {
        this._handleInvalidResponse(item);

        // report error in console
        console.log('lookup initialization error: request for item not found. Item id ' + item.id);
        return;
      }

      ivRequest.isCompleted = true;
      ivRequest.item = item;

      // check if all requests are complete
      if (this._countIncompleteRequests(this._viewModel.initialValueRequestsQueue) > 0) return;
      // TODO(ij): delete below if above works
      // var queueComplete = true;
      // this._viewModel.initialValueRequestsQueue.forEach(function (request) {
      //   queueComplete = queueComplete && request.isCompleted;
      // });

      // if (!queueComplete) return;

      this._handleInitialRequestsQueueComplete(item);
    },

    _handleInitialRequestsQueueComplete: function(item) {
      // place data from queue into _viewModel.initialItems array
      var initialItems = [];
      this._viewModel.initialValueRequestsQueue.forEach(function (request) {
        // skip incomplete requests
        if (!request.isCompleted) return;

        var option = {
          title: request.item.title,
          value: request.item.id,
          itemRef: request.item
        };
        initialItems.push(option);

      }, this);
      this._viewModel.initialItems = initialItems;

      // clear the queue
      this._viewModel.initialValueRequestsQueue = [];

      // detach event listeners from coreActivities
      this._viewModel.initialValueActivitiesQueue.forEach(function(a){ 
        a.removeEventListener('response', this._boundInitialValueActivityResponseHandler);
        a.removeEventListener('error', this._boundInitialValueActivityErrorHanlder);
      }.bind(this));
      // clear the coreActivities queue
      this._viewModel.initialValueActivitiesQueue = [];

      // clear invalidItems array
      this._viewModel.invalidItems = [];

      // sync options and items
      this._viewModel.itemsRequestsComplete = true;
      this._syncOptionsAndItemsRequests();

      if (!this._viewModel.initialValueRequestsQueue.length) {
        this.disabled = false;
      }

      // we update value and selected items first 
      this._updateLookupValue(this._computeItemsViewStrValue());
      this._updateLookupSelectedItems();
      
      // and fire events next, because its expected that both value and selectedItems be up to date when events are fired
      this._fireValueChangedEvent();
      this._fireSelectedItemsChangedEvent();

      this.fire('at-form-lookup-initialized', {
        data: item
      });
    },

    /*
      When using remote data source selected items that are present in options (if any) need to be removed
    */
    _syncOptionsAndItemsRequests: function() {
      // wait for all requests to complete
      if (!this._viewModel.optionsRequestComplete || !this._viewModel.itemsRequestsComplete) return;

      var isMulti = this._isMultiSelect();

      // original options are used for .value and .selectedItems computation
      // when options request completes, _viewModel.originalOptions holds options from remote url
      var originalOptions = this._viewModel.originalOptions;

      // available options are used for filtering and highlighting
      // when options request completes, _viewModel.availableOptions holds available options
      var availableOptions = this._viewModel.availableOptions; 

      // when items requests complete (there can be more than one), _viewModel
      var initialItems = this._viewModel.initialItems;
      if (!initialItems.length) {
        initialItems = JSON.parse(JSON.stringify(this.$.itemsView.items));
      }

      var selectedItems = [];

      initialItems.forEach(function(item, index) { 

        // item structure is  item: { title, value, itemRef }
        // original options in have same structure

        // search is done by id
        var itemId = item.value;

        // if item.id exists in available options, remove that item from available options
        var indexInAvailable = this._findIndexOfId(availableOptions, itemId);
        if (isMulti && indexInAvailable > -1) {
          availableOptions.splice(indexInAvailable, 1);
        
        } else if (!isMulti && indexInAvailable > -1) {
          availableOptions[indexInAvailable].selected = true;
        }

        // if item.id doesn't exist in original options, it should be added to original options
        var indexInOriginal = this._findIndexOfId(originalOptions, itemId);
        if (indexInOriginal < 0) {
          originalOptions.push(item);
        }
          
        // construct object selectedItem to be given to itemsView { title, titleArr, value }
        var si = {
          title: item.title,
          value: itemId,
          titleArr: [],
          selected: false
        };

        this._viewModel.availableOptions = availableOptions;

        selectedItems.push(si);
      }, this);

      // update itemsView
      this.$.itemsView.set('items', selectedItems);

      // filter and highlight available options if necessary
      var clone = JSON.parse(JSON.stringify(this._viewModel.availableOptions));
      this.$.optionsView.set('items', clone);

      // clear initialItems as it will interfere with new values from server
      this._viewModel.initialItems = [];
    },

    _findIndexOfId: function(array, id) {
      var result = -1;
      
      for (var i = 0; i < array.length && result < 0; i++) {
        var item = array[i];
        result = item.value === id ? i : result;
      }

      return result;
    },

    _findItemWithId: function(array, id) {
      var result = undefined;
      
      for (var i = 0; i < array.length && !result; i++) {
        var item = array[i];
        result = item.value === id ? item : result;
      }

      return result;
    },

    _setupEventListeners: function() {
      var filterTextInput = this._getInput();

      if (!this._boundFilterTextInputFocusHandler) {
        this._boundFilterTextInputFocusHandler = this._handleFilterTextInputFocusEvent.bind(this);
      }
      filterTextInput.addEventListener('focus', this._boundFilterTextInputFocusHandler);

      if (!this._boundFilterTextInputBlurHandler) {
        this._boundFilterTextInputBlurHandler = this._handleFilterTextInputBlurEvent.bind(this);
      }
      filterTextInput.addEventListener('blur', this._boundFilterTextInputBlurHandler);

      if (!this._boundFilterTextInputKeydownHandler) {
        this._boundFilterTextInputKeydownHandler = this._handleFilterTextInputKeydownEvent.bind(this);
      }
      filterTextInput.addEventListener('keydown', this._boundFilterTextInputKeydownHandler);

      if (!this._boundItemsViewItemsDeletedHandler) {
        this._boundItemsViewItemsDeletedHandler = this._handleItemsViewItemsDeletedEvent.bind(this);
      }
      this.$.itemsView.addEventListener('items-deleted', this._boundItemsViewItemsDeletedHandler);

      if (!this._boundOptionsViewOptionSelectedHadler) {
        this._boundOptionsViewOptionSelectedHadler = this._handleOptionsViewOptionSelectedEvent.bind(this);
      }
      this.$.optionsView.addEventListener('option-selected', this._boundOptionsViewOptionSelectedHadler);

      if (!this._boundItemsViewFilterChangedHandler) {
        this._boundItemsViewFilterChangedHandler = this._handleItemsViewFilterChangedEvent.bind(this);
      }
      this.$.itemsView.addEventListener('filter-changed', this._boundItemsViewFilterChangedHandler);
    },

    _detachEventListeners: function() {
      var itemsView = this.$.itemsView;
      var filterTextInput = this._getInput();
      filterTextInput.removeEventListener('focus', this._boundFilterTextInputFocusHandler);
      filterTextInput.removeEventListener('blur', this._boundFilterTextInputBlurHandler);

      filterTextInput.removeEventListener('keydown', this._boundFilterTextInputKeydownHandler);
      
      itemsView.removeEventListener('items-deleted', this._boundItemsViewItemsDeletedHandler);

      this.$.optionsView.removeEventListener('option-selected', this._boundOptionsViewOptionSelectedHadler);

      this.$.itemsView.removeEventListener('filter-changed', this._boundItemsViewFilterChangedHandler);
    },

    _handleFilterTextInputFocusEvent: function(event) {
      this.$.contentContainer.setAttribute('focused', '');

      var isFull = this._isFull();
      var isMulti = this._isMultiSelect();
      
      if (isFull && isMulti) return;

      if (!this.$.optionsView.items.length) return;

      this._openDropdown();
    },

    _handleFilterTextInputBlurEvent: function(event) {

      if (!event.relatedTarget) {
        this.$.contentContainer.removeAttribute('focused');
        // if focus didn't transfer to any other element hide the dropdown
        this._closeDropdown();
        return;
      }

      // if element receiving focus is at-core-dropdown-impl return
      if (event.relatedTarget.nodeName === "AT-CORE-DROPDOWN-IMPL") return;
      this.$.contentContainer.removeAttribute('focused');

      // if element receiving focus is an item in <items-view> return
      var rt = event.relatedTarget;
      if (this.$.itemsView.contains(rt) && rt.classList.contains('item')) {
        this._getInput().focus();
        return;
      }

      // if element receiving focus is outside at-form-lookup hide the dropdown
      this._closeDropdown();
    },

    _handleFilterTextInputKeydownEvent: function(event) {
      var keyCode = event.keyCode;

      var VK_BACKSPACE = 8;
      var VK_TAB = 9;
      var VK_ENTER = 13;
      var VK_UP = 38;
      var VK_DOWN = 40;
      var VK_ESCAPE = 27;

      switch (keyCode) {
        case VK_ESCAPE:
          this._closeDropdown();
          break;

        case VK_ENTER:
          event.preventDefault();
        case VK_TAB:
          if (!this.$.coreDropdown.open) return;
          // select highlighted element
          var selectedIndex = this._findSelectedIndex(this.$.optionsView.items);
          if (selectedIndex < 0) {
            this._getInput().blur();
            return;
          }
          this._selectOptionAtIndex(selectedIndex);

          // for keyboard input select item near to currently selected to make selecting next more user friendly
          if (selectedIndex === this.$.optionsView.items.length) selectedIndex-=1;
          this.$.optionsView.set('items.' + selectedIndex + '.selected', true);
          break;

        case VK_UP: 
          // highlight previous element 
          this._highlightPrevious(this.$.optionsView.items);
          break;

        case VK_DOWN: 
          // highlight next element 
          this._highlightNext(this.$.optionsView.items);
          break;

        case VK_BACKSPACE: 
          if (this._isFull()) return;
          this._openDropdown();
          break;
      }
    },

    _findSelectedIndex: function(options) {
      for (var i = 0; i < options.length; i++) {
        var option = options[i];
        if (option.selected) return i;
      }
      return -1;
    },

    _selectOptionAtIndex: function(selectedIndex) {
      var isFull = this._isFull();
      var isMulti = this._isMultiSelect();
      
      if (isFull && isMulti) return;

      var option = this.$.optionsView.items[selectedIndex];

      // based on selected option value, find the original option in available options and push that option into itemsView.items
      var originalOption = this._findItemWithId(this._viewModel.availableOptions, option.value);
      var newOptionSelected = !originalOption;

      if (!this.allowNewItems) {
        originalOption.selected = false;

      } else if (!originalOption) {
        // original option doesn't exist; its should be created
        originalOption = {
          title: option.value, 
          value: option.value
        };

        // place original option into _viewModel original options
        this._viewModel.originalOptions.push(JSON.parse(JSON.stringify(originalOption)));
        originalOption.selected = false;
        originalOption.titleArr = [];
      }

      if (!isMulti) {
        if (isFull) {
          // maxItems == 1 and itemsView already displays selected item
          // replace that item with newly selected one
          this.$.itemsView.splice('items', 0, 1, originalOption);

        } else {
          this.$.itemsView.push('items', originalOption);

          if (newOptionSelected) {
            // remove new option from dropdown options
            this.$.optionsView.shift('items');

            // add it to available options
            this._viewModel.availableOptions.push({
              title: originalOption.title,
              value: originalOption.value
            });
          }
        }

        // in single selection mode filter text should be cleared
        this._getInput().value = "";
        this.$.itemsView._updateFilterTextInputWidth();

        this._closeDropdown();

      } else {
        // remove found option from availableOptions
        var indexInAvailable = this._findIndexOfId(this._viewModel.availableOptions, originalOption.value);
        this._viewModel.availableOptions.splice(indexInAvailable, 1);

        // add selected option to the items view, to the left of input field
        var indexOfInput = this.$.itemsView._getInputIndex();
        
        var len = this.$.itemsView.items.length;
        if (!len) {
          // insert when empty
          this.$.itemsView.push('items', originalOption);

        } else if (len && indexOfInput < len) {
          // insert when not empty at the begining or middle
          this.$.itemsView.splice('items', indexOfInput, 0, originalOption);
  
        } else {
          // insert when not empty at the end
          this.$.itemsView.push('items', originalOption);
        }

        var optionsItems = JSON.parse(JSON.stringify(this.$.optionsView.items));
        optionsItems.splice(selectedIndex, 1);
        this.$.optionsView.set('items', []);
        this.$.optionsView.set('items', optionsItems);
        if (!this.$.optionsView.items.length) {
          this._closeDropdown();
        }
      }

      isFull = this._isFull();
      if (isFull) {
        var input = this._getInput();

        if (isMulti) {
          input.value = "";
          this.$.itemsView._updateFilterTextInputWidth();

          // if maxItems have been selected in multi selection mode close the dropdown
          this._closeDropdown();
        
        } else if (newOptionSelected) {
          // when new options is selected, clear input field text and blur
          input.value = '';
          input.blur();
          this.$.itemsView._updateFilterTextInputWidth();
        }

      } else if (isMulti) {
        Polymer.dom.flush();
        this.$.coreDropdown.updateDropdownPosition(this.$.itemsView);
        this.$.coreDropdown.updateContainerAndOutlineSize();
      }

      // update .value
      this._updateLookupValue(this._computeItemsViewStrValue());

      // update .selectedItems
      this._updateLookupSelectedItems();

      // we update value and selected items first 
      // and fire events next, because its expected that both value and selectedItems be up to date when events are fired

      // fire value-changed event
      this._fireValueChangedEvent();

      // fire selected-items-changed event
      this._fireSelectedItemsChangedEvent();

      // validate
      this.validate();
    },

    _highlightPrevious: function(options) {
      var selectedIndex = this._findSelectedIndex(options);
      if (selectedIndex < 1) return;
      this.$.optionsView.set('items.' + selectedIndex + '.selected', false);
      selectedIndex -= 1;
      if (selectedIndex < 0) return;
      this.$.optionsView.set('items.' + selectedIndex + '.selected', true);
      this._udpateOptionsViewScrollTop();
    },

    _highlightNext: function(options) {
      var selectedIndex = this._findSelectedIndex(options);
      if (selectedIndex > -1 && selectedIndex < options.length-1) {
        this.$.optionsView.set('items.' + selectedIndex + '.selected', false);
      }
      selectedIndex +=1;
      if (selectedIndex > options.length) return;
      this.$.optionsView.set('items.' + selectedIndex + '.selected', true);
      this._udpateOptionsViewScrollTop();
    },

    _udpateOptionsViewScrollTop: function() {
      var selectedOption = this.$.optionsView.querySelector('[selected]');
      if (!selectedOption) return;
      var sobcr = selectedOption.getBoundingClientRect();
      var soTop = sobcr.top;

      var ovcc = this.$.optionsView.getBoundingClientRect();
      var ovHeight = ovcc.height;
      var ovTop = ovcc.top;
      
      var currentTop = this.$.optionsView.scrollTop;
      var topDiff = Math.abs(soTop - ovTop + currentTop);

      if (topDiff < currentTop) {
        this.$.optionsView.scrollTop = topDiff;
        
      } else if (topDiff >= (ovHeight+currentTop)) {
        var topVal = topDiff - ovHeight + sobcr.height;
        this.$.optionsView.scrollTop = topVal;
      }
    },

    _handleItemsViewItemsDeletedEvent: function(event) {
      var itemsDeleted = event.detail.value;
      
      if (this._isMultiSelect()) {
        // return deleted items to available options
        itemsDeleted.forEach(function(item) {
          this._viewModel.availableOptions.push(item);
        }.bind(this));

        this._viewModel.availableOptions.sort(function(i1, i2) {  
          if (i1.value === i2.value) return 0;
          return i1.value > i2.value ? 1 : -1;
        });

      } else if (!this._viewModel.availableOptions.length) {
        // its single select and there is only one option available
        itemsDeleted.forEach(function(item) {
          this._viewModel.availableOptions.push(item);
        }.bind(this));
      }

      var filteredOptions = this._filterAndHighlightOptions(this._getInput().value);
      this.$.optionsView.set('items', []);
      this.$.optionsView.set('items', filteredOptions);

      if (itemsDeleted && itemsDeleted.length && !this.$.coreDropdown.open) {
        var filterText = this._getInput().value;
        if (filterText !== "") {
          // focusing the input will open the dropdown 
          this._getInput().focus();
          if (!this.$.coreDropdown.open) {
            this._openDropdown();
          }

        } else {
          // if filterText is empty, we need all options in dropdown not just deleted ones
          var remoteUrl = this.xurl || this.url;
          this._sendRequestToQueryOptions(remoteUrl, filterText);
          this._viewModel.openDropdownOnResponse = true;
        }
      }

      Polymer.dom.flush();
      this.$.coreDropdown.updateContainerAndOutlineSize();
      this.$.coreDropdown.updateDropdownPosition(this.$.itemsView);

      // update .value 
      this._updateLookupValue(this._computeItemsViewStrValue());

      // update .selectedItems 
      this._updateLookupSelectedItems();

      // we update value and selected items first 
      // and fire events next, because its expected that both value and selectedItems be up to date when events are fired

      // fire value-changed event
      this._fireValueChangedEvent();

      // fire selected-items-changed event
      this._fireSelectedItemsChangedEvent();
    },

    _handleOptionsViewOptionSelectedEvent: function(event) {
      var selectedIndex = this._findSelectedIndex(this.$.optionsView.items);
      if (selectedIndex > -1) {
        this.$.optionsView.set('items.' + selectedIndex + '.selected', false);
      }
      var index = event.detail.index;
      this.$.optionsView.set('items.' + index + '.selected', true);
      this._selectOptionAtIndex(index);

      if (this._isMultiSelect()) {
        this._getInput().focus();
      } else {
        this.$.contentContainer.removeAttribute('focused');
      }      
    },

    _handleItemsViewFilterChangedEvent: function(event) {
      var filterText = event.detail.value;
      var remoteUrl = this.xurl || this.url;
      if (!remoteUrl) {
        // do the filtering of local data
        var filteredOptions = this._filterAndHighlightOptions(filterText);

        this.$.optionsView.set('items', []);
        this.$.optionsView.set('items', filteredOptions);

        // filter text input has focus, but if initially dropdown was empty and allowNewItems is true
        // new item is added to options; we should open the dropdown
        Polymer.dom.flush();
        if (!this.$.coreDropdown.open && this.allowNewItems) { 
          this._openDropdown();

        } else {
          // if options are filtered while dropdown is open we need to update dropdown size
          this.$.coreDropdown.updateContainerAndOutlineSize();
        }

      } else {
        // if (!filterText.length) {
        //   // clear selected options because new and different items will be fetched from the remoteUrl
        //   this.$.itemsView.set('items', []);
        //   this._updateLookupValue('');
        //   this._updateLookupSelectedItems();
        // }

        // send new request to the server with filter text as query
        this._sendRequestToQueryOptions(remoteUrl, filterText);
        this._viewModel.openDropdownOnResponse = true;
      }
    },

    _filterAndHighlightOptions: function(filterText) {
      var filteredOptions = [];

      // 1. filter the options 
      if (filterText) {
        var sifter = new window.atFormLookup.Sifter(this._viewModel.availableOptions);
        var results = sifter.search(filterText, {
          score: sifter.getScoreFunction(filterText, {
            fields: 'title',
            conjunction: 'and',
            sort: {
              field: 'value'
            }
          })
        });
        
        var availalble = this._viewModel.availableOptions;
        results.items.forEach(function(item) {
          var option = availalble[item.id];
          filteredOptions.push(JSON.parse(JSON.stringify(option)));
        });

      } else {

        var isRemoteMode = this.xurl || this.url;
        if (isRemoteMode) {
          filteredOptions = this._computeAvailableOptionsFromOriginalOptions();

        } else {
          // restore available options
          filteredOptions = JSON.parse(JSON.stringify(this._viewModel.availableOptions));
        }

      }

      // 2. highlight the options
      this._highlightOptions(filteredOptions, filterText);

      // add option to add new option/item
      if (filterText && this.allowNewItems) {
        // if option with filterText as value already exists in filteredOptions, do not add option to add item
        var exists = false;
        for (var i = 0; i < filteredOptions.length && !exists; i++) {
          var fo = filteredOptions[i];
          exists = fo.value === filterText;
        }

        if (!exists) {
          filteredOptions.unshift({
            title: 'Add option ' + filterText,
            value: filterText
          });
        }
      }

      // 3. return result
      return filteredOptions;
    },

    // this function is here to improve compatibility with form designer
    xvaluelistChanged: function(newValue, oldValue) {
      // this._availableChanged(newValue, oldValue);
    },

    // this function is here to avoid console errors with setting selectedItems because its readonly
    set selectedItems(newValue) {},

    focus: function() {
      this._getFocusableElement().focus();
    },

    // this function is part of the hint/validation API
    // hint should be displayed when element gains focus
    // behavior can not know when element gained focus
    // but if gived focusable element it can attach to its focus event
    // it should return focusable element if available or null if focusable element doesn't exist
    _getFocusableElement: function () {
      var focusable = this.$.itemsView.$.filterTextInput;
      return focusable;
    },

    // 
    // 
    // 
    // HELPER FUNCTIONS
    // 
    // 
    // 

    _isString: function(obj) {
      return Object.prototype.toString.apply(obj) === "[object String]";
    },
    
    // this function adds support for maxItems values as textual representation of a number
    // this support is required by form and dashboard designers
    _getMaxItemsAsNumber: function() {
      var lVal = this.maxItems;
      if (this._isString(this.maxItems)) {
        lVal = parseInt(this.maxItems);
        if (window.isNaN(lVal)) { lVal = 1; }
      }
      return lVal;
    },

    // returns true if maxItems have already been selected from available options
    _isFull: function() {
      var maxItems = this._getMaxItemsAsNumber();
      return maxItems === 0 ? !this._viewModel.availableOptions.length : this.$.itemsView.items.length === maxItems;
    },

    // returns true if user can select more than one item
    _isMultiSelect: function() {
      var maxItems = this._getMaxItemsAsNumber();
      // if maxItems = 0 there is no limit for item selection, user can select as many items as there are available options
      // if maxItems > 1 user can select maxItems items from available options
      return maxItems !== 1;
    },

    _getInput: function() {
      return this.$.itemsView.$.filterTextInput;
    },

    _computeAvailableOptionsFromOriginalOptions: function() {
      var isMulti = this._isMultiSelect();
      var result = [];
      var os = this._viewModel.originalOptions;
      os.forEach(function(o, i) {
        var value = o.itemRef ? (o.itemRef.id || o.itemRef.value) : o.value;
        var a = {
          title: o.title,
          value: value,
          selected: false, // we use selected to mark item as selected in dropdown
          titleArr: [] // we use titleArr to fix a bug with dom-if / dom-repeat combo, where dom-repeat is evaluated when dom-if evaluates to false
        };

        // if original option is in selectedItems do not add to available
        var indexInSelected = this._findIndexOfId(this.$.itemsView.items, a.value);
        if (indexInSelected < 0) {
          result.push(a);
        
        // but in single select mode add original option to results and mark it as selected
        } else if (!isMulti) {
          a.selected = true;
          result.push(a);
        }

      }, this);
      return result;
    },

    _highlightOptions: function(options, token) {
      if (!token) return;

      var highlightTitle = function(title) {
        var result = [];
        var tokenLowerCase = token.toLowerCase();
        var titleLowerCase = title.toLowerCase();
        var tokenLen = token.length;
        var prev = 0;
        var pos = titleLowerCase.indexOf(tokenLowerCase, prev);

        if (pos < 0) return title;
        
        while (pos > -1) {
          var textBefore = title.slice(prev, pos);
          if (textBefore.length) {
            result.push(textBefore);
          }

          var titlePart = title.slice(pos, pos+tokenLen);
          result.push({ text: titlePart });
          pos+= tokenLen;
          prev = pos;
          pos = titleLowerCase.indexOf(tokenLowerCase, pos);
        }

        if (prev < title.length) {
          var remTxt = title.slice(prev, title.length);
          result.push(remTxt);
        }

        return result;
      };

      function isArray(obj) {
        return Object.prototype.toString.apply(obj) === "[object Array]";
      }

      options.forEach(function(option, index) { 
        var t = highlightTitle(option.title);
        option.titleArr = isArray(t) ? t : [];
      });
    },

    _computeItemsViewStrValue: function() {
      var valuesArr = [];
      this.$.itemsView.items.forEach(function(item){ 
        valuesArr.push(item.value);
      });
      var newValue = valuesArr.join(',');

      return newValue;
    },

    _updateLookupValue: function(newValue) {
      function isFunction(obj) {
        return Object.prototype.toString.apply(obj) === "[object Function]";
      }
      function isString(obj) {
        return Object.prototype.toString.apply(obj) === "[object String]";
      }

      var valueStr = isString(newValue) ? newValue : JSON.stringify(newValue);

      if (isFunction(newValue)) {
        valueStr = "";
      }

      this._skipInitialization = true;
      this._lastUsedValue = newValue;
      this.value = newValue;
      this._skipInitialization = false;
    },

    _fireValueChangedEvent: function(newValue) {
      this.fire('value-changed', { value: this.value }, { bubbles: false});
    },

    _updateLookupSelectedItems: function(newValue) {
      var os = this._viewModel.originalOptions;
      var selectedItems = [];
      this.$.itemsView.items.forEach(function(item) {
        var tmp = this._findItemWithId(os, item.value);
        selectedItems.push(tmp.itemRef || tmp);
      }, this);
      this._setSelectedItems(selectedItems);
    },

    _fireSelectedItemsChangedEvent: function() {
      this.fire('selected-items-changed', { value: this.selectedItems }, { bubbles: false});
    },

    // for a given url computes the base url and query params
    _computeBaseUrlAndQueryParams: function(url) {
      var result = {
        baseUrl: '',
        queryParams: []
      };

      var urlParts = url.split('?');
      result.baseUrl = urlParts[0];
      var urlQueryString = urlParts.length > 1 ? urlParts[1] : '';
      var queryParams = urlQueryString.split('&');
      queryParams.forEach(function(queryParam){
        queryParam = queryParam.trim();
        // skip empty params
        if (!queryParam) return;

        // skip malformed queryparams
        if (queryParam.indexOf('=') === -1)  {
          console.log('query parameter ' + queryParam + ' is invalid');
          return;
        }

        var paramParts = queryParam.split('=');
        var paramName = paramParts[0];
        var paramValue = paramParts.length > 1 ? paramParts[1] : '';
        var paramObj = {
          name: paramName,
          value: paramValue
        };
        result.queryParams.push(paramObj);
      });

      return result;
    },

    _openDropdown: function() {
      var ccWidth = 0;
      var displayValue = window.getComputedStyle(this).getPropertyValue('display');
      var isInline = /^inline/gi.test(displayValue);
      
      var ccClientRect = this.$.contentContainer.getBoundingClientRect();
      ccWidth = ccClientRect.width;
      
      if (isInline) {
        ccWidth = ccWidth < 150 ? 150 : ccWidth;

      } else {
        this.classList.remove('inline-and-empty-width');
      }
      
      this.$.optionsView.style.width = ccWidth + 'px';

      this.$.coreDropdown.show(null, this.$.itemsView);

      Polymer.dom(this.$.itemsView.$.dropdownArrow).classList.add('open');

      this._udpateOptionsViewScrollTop();

      Polymer.dom().flush();
      this.$.coreDropdown.updateContainerAndOutlineSize();
    },

    _closeDropdown: function() {
      this.$.coreDropdown.hide();
      Polymer.dom(this.$.itemsView.$.dropdownArrow).classList.remove('open');
    }
  });

  /**
   * sifter.js
   * Copyright (c) 2013 Brian Reavis & contributors
   *
   * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this
   * file except in compliance with the License. You may obtain a copy of the License at:
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
   * ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   *
   * @author Brian Reavis <brian@thirdroute.com>
   */

  (function(root, factory) {
    "use strict";
    root.Sifter = factory();
  }(window.atFormLookup = window.atFormLookup || {}, function() {
    "use strict";

    // utilities
    //----------------------------------------

    var cmp = function(a, b) {
      if (typeof a === 'number' && typeof b === 'number') {
        return a > b ? 1 : (a < b ? -1 : 0);
      }
      a = String(a || '').toLowerCase();
      b = String(b || '').toLowerCase();
      if (a > b) {
        return 1;
      }
      if (b > a) {
        return -1;
      }
      return 0;
    };

    var extend = function(a, b) {
      var i, n, k, object;
      for (i = 1, n = arguments.length; i < n; i += 1) {
        object = arguments[i];
        if (!object) {
          continue;
        }
        for (k in object) {
          if (object.hasOwnProperty(k)) {
            a[k] = object[k];
          }
        }
      }
      return a;
    };

    var trim = function(str) {
      return String(str).replace(/^\s+|\s+$|/g, '');
    };

    var escape_regex = function(str) {
      return String(str).replace(/([.?*+^$[\]\\(){}|-])/g, '\\$1');
    };

    var is_array = Array.isArray || function(object) {
      return Object.prototype.toString.call(object) === '[object Array]';
    };

    var DIACRITICS = {
      'a': '[a ]',
      'c': '[c]',
      'd': '[d]',
      'e': '[e]',
      'i': '[i]',
      'n': '[n]',
      'o': '[o]',
      'r': '[r]',
      's': '[s ]',
      't': '[t]',
      'u': '[u]',
      'y': '[y]',
      'z': '[z]'
    };

    // export
    //----------------------------------------

    /**
     * Textually searches arrays and hashes of objects
     * by property (or multiple properties). Designed
     * specifically for autocomplete.
     *
     * @constructor
     * @param {array|object} items
     * @param {object} settings
     */
    var Sifter = function(items, settings) {
      this.items = items;
      this.settings = settings || {
        diacritics: false
      };
    };

    /**
     * Splits a search string into an array of individual
     * regexps to be used to match results.
     *
     * @param {string} query
     * @returns {array}
     */
    Sifter.prototype.tokenize = function(query) {
      query = trim(String(query || '').toLowerCase());
      if (!query || !query.length) {
        return [];
      }

      var i, n, regex, letter,
        tokens = [],
        words = query.split(/ +/);

      for (i = 0, n = words.length; i < n; i += 1) {
        regex = escape_regex(words[i]);
        if (this.settings.diacritics) {
          for (letter in DIACRITICS) {
            if (DIACRITICS.hasOwnProperty(letter)) {
              regex = regex.replace(new RegExp(letter, 'g'), DIACRITICS[letter]);
            }
          }
        }
        tokens.push({
          string: words[i],
          regex: new RegExp(regex, 'i')
        });
      }

      return tokens;
    };

    /**
     * Iterates over arrays and hashes.
     *
     * ```
     * this.iterator(this.items, function(item, id) {
     *    // invoked for each item
     * });
     * ```
     *
     * @param {array|object} object
     */
    Sifter.prototype.iterator = function(object, callback) {
      var iterator, i, n;
      if (is_array(object)) {
        iterator = Array.prototype.forEach || function(callback) {
          for (i = 0, n = this.length; i < n; i += 1) {
            callback(this[i], i, this);
          }
        };
      } else {
        iterator = function(callback) {
          var key;
          for (key in this) {
            if (this.hasOwnProperty(key)) {
              callback(this[key], key, this);
            }
          }
        };
      }

      iterator.apply(object, [callback]);
    };

    /**
     * Returns a function to be used to score individual results.
     *
     * Good matches will have a higher score than poor matches.
     * If an item is not a match, 0 will be returned by the function.
     *
     * @param {object|string} search
     * @param {object} options (optional)
     * @returns {function}
     */
    Sifter.prototype.getScoreFunction = function(search, options) {
      var self, fields, tokens, token_count;

      self = this;
      search = self.prepareSearch(search, options);
      tokens = search.tokens;
      fields = search.options.fields;
      token_count = tokens.length;

      /**
       * Calculates how close of a match the
       * given value is against a search token.
       *
       * @param {mixed} value
       * @param {object} token
       * @return {number}
       */
      var scoreValue = function(value, token) {
        var score, pos;

        if (!value) {
          return 0;
        }
        value = String(value || '');
        pos = value.search(token.regex);
        if (pos === -1) {
          return 0;
        }
        score = token.string.length / value.length;
        if (pos === 0) {
          score += 0.5;
        }
        return score;
      };

      /**
       * Calculates the score of an object
       * against the search query.
       *
       * @param {object} token
       * @param {object} data
       * @return {number}
       */
      var scoreObject = (function() {
        var field_count = fields.length;
        if (!field_count) {
          return function() {
            return 0;
          };
        }
        if (field_count === 1) {
          return function(token, data) {
            return scoreValue(data[fields[0]], token);
          };
        }
        return function(token, data) {
          var i, sum;
          for (i = 0, sum = 0; i < field_count; i += 1) {
            sum += scoreValue(data[fields[i]], token);
          }
          return sum / field_count;
        };
      }());

      if (!token_count) {
        return function() {
          return 0;
        };
      }
      if (token_count === 1) {
        return function(data) {
          return scoreObject(tokens[0], data);
        };
      }

      if (search.options.conjunction === 'and') {
        return function(data) {
          var score, i, sum;
          for (i = 0, sum = 0; i < token_count; i += 1) {
            score = scoreObject(tokens[i], data);
            if (score <= 0) {
              return 0;
            }
            sum += score;
          }
          return sum / token_count;
        };
      } else {
        return function(data) {
          var i, sum;
          for (i = 0, sum = 0; i < token_count; i += 1) {
            sum += scoreObject(tokens[i], data);
          }
          return sum / token_count;
        };
      }
    };

    /**
     * Returns a function that can be used to compare two
     * results, for sorting purposes. If no sorting should
     * be performed, `null` will be returned.
     *
     * @param {string|object} search
     * @param {object} options
     * @return function(a,b)
     */
    Sifter.prototype.getSortFunction = function(search, options) {
      var i, n, self, field, fields, fields_count, multiplier, multipliers, get_field, implicit_score, sort;

      self = this;
      search = self.prepareSearch(search, options);
      sort = (!search.query && options.sort_empty) || options.sort;

      /**
       * Fetches the specified sort field value
       * from a search result item.
       *
       * @param  {string} name
       * @param  {object} result
       * @return {mixed}
       */
      get_field = function(name, result) {
        if (name === '$score') {
          return result.score;
        }
        return self.items[result.id][name];
      };

      // parse options
      fields = [];
      if (sort) {
        for (i = 0, n = sort.length; i < n; i += 1) {
          if (search.query || sort[i].field !== '$score') {
            fields.push(sort[i]);
          }
        }
      }

      // the "$score" field is implied to be the primary
      // sort field, unless it's manually specified
      if (search.query) {
        implicit_score = true;
        for (i = 0, n = fields.length; i < n; i += 1) {
          if (fields[i].field === '$score') {
            implicit_score = false;
            break;
          }
        }
        if (implicit_score) {
          fields.unshift({
            field: '$score',
            direction: 'desc'
          });
        }
      } else {
        for (i = 0, n = fields.length; i < n; i += 1) {
          if (fields[i].field === '$score') {
            fields.splice(i, 1);
            break;
          }
        }
      }

      multipliers = [];
      for (i = 0, n = fields.length; i < n; i += 1) {
        multipliers.push(fields[i].direction === 'desc' ? -1 : 1);
      }

      // build function
      fields_count = fields.length;
      if (!fields_count) {
        return null;
      } else if (fields_count === 1) {
        field = fields[0].field;
        multiplier = multipliers[0];
        return function(a, b) {
          return multiplier * cmp(
            get_field(field, a),
            get_field(field, b)
          );
        };
      } else {
        return function(a, b) {
          var i, result, a_value, b_value, field;
          for (i = 0; i < fields_count; i += 1) {
            field = fields[i].field;
            result = multipliers[i] * cmp(
              get_field(field, a),
              get_field(field, b)
            );
            if (result) {
              return result;
            }
          }
          return 0;
        };
      }
    };

    /**
     * Parses a search query and returns an object
     * with tokens and fields ready to be populated
     * with results.
     *
     * @param {string} query
     * @param {object} options
     * @returns {object}
     */
    Sifter.prototype.prepareSearch = function(query, options) {
      if (typeof query === 'object') {
        return query;
      }

      options = extend({}, options);

      var option_fields = options.fields;
      var option_sort = options.sort;
      var option_sort_empty = options.sort_empty;

      if (option_fields && !is_array(option_fields)) {
        options.fields = [option_fields];
      }
      if (option_sort && !is_array(option_sort)) {
        options.sort = [option_sort];
      }
      if (option_sort_empty && !is_array(option_sort_empty)) {
        options.sort_empty = [option_sort_empty];
      }

      return {
        options: options,
        query: String(query || '').toLowerCase(),
        tokens: this.tokenize(query),
        total: 0,
        items: []
      };
    };

    /**
     * Searches through all items and returns a sorted array of matches.
     *
     * The `options` parameter can contain:
     *
     *  -fields {string|array}
     *  -sort {array}
     *  -score {function}
     *  -filter {bool}
     *  -limit {integer}
     *
     * Returns an object containing:
     *
     *  -options {object}
     *  -query {string}
     *  -tokens {array}
     *  -total {int}
     *  -items {array}
     *
     * @param {string} query
     * @param {object} options
     * @returns {object}
     */
    Sifter.prototype.search = function(query, options) {
      var self = this,
        value,
        score,
        search,
        calculateScore,
        fn_sort,
        fn_score;

      search = this.prepareSearch(query, options);
      options = search.options;
      query = search.query;

      // generate result scoring function
      fn_score = options.score || self.getScoreFunction(search);

      // perform search and sort
      if (query.length) {
        self.iterator(self.items, function(item, id) {
          score = fn_score(item);
          if (options.filter === false || score > 0) {
            search.items.push({
              'score': score,
              'id': id
            });
          }
        });
      } else {
        self.iterator(self.items, function(item, id) {
          search.items.push({
            'score': 1,
            'id': id
          });
        });
      }

      fn_sort = self.getSortFunction(search, options);
      if (fn_sort) {
        search.items.sort(fn_sort);
      }

      // apply limits
      search.total = search.items.length;
      if (typeof options.limit === 'number') {
        search.items = search.items.slice(0, options.limit);
      }

      return search;
    };

    return Sifter;
  }));

  /**
   * For at-form-lookup-afterAjax event <br/>
   * event.detail.response holds data received from the server <br/>
   * transform the each item in data as follows <br/>
   * for each item in data create a new object with three properties: title, value and itemRef <br/>
   * 1) provide adequate value for title from item <br/>
   * 2) provide adequate value for value from item <br/>
   * 3) assign item (or any parts of it) to itemRef <br/>
   * in selectedItems you will get what was placed in itemRef <br/>
   * 
   * @event at-form-lookup-afterAjax
   */ 
</script>
